[{"title":"3090.每个字符最多出现两次的最长子字符串","path":"/2024/09/14/3090-每个字符最多出现两次的最长子字符串/","content":"题目给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该 子字符串 的 最大 长度。 示例 1： 输入： s &#x3D; “bcbbbcba” 输出： 4 解释： 以下子字符串长度为 4，并且每个字符最多出现两次：&quot;bcbbbcba&quot;。 示例 2： 输入： s &#x3D; “aaaa” 输出： 2 解释： 以下子字符串长度为 2，并且每个字符最多出现两次：&quot;aaaa&quot;。 提示： 2 &lt;= s.length &lt;= 100 s 仅由小写英文字母组成。 题解1234567891011121314151617class Solution &#123; public int maximumLengthSubstring(String s) &#123; int n=s.length(); HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int len=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c = s.charAt(right); while(left&lt;right&amp;&amp;map.getOrDefault(c, 0) == 2)&#123; map.put(s.charAt(left),map.get(s.charAt(left))-1); left++; &#125; map.put(c,map.getOrDefault(c, 0)+1); len=Math.max(len,right-left+1); &#125; return len; &#125;&#125; 不太优雅，使用merge 123456789101112131415161718class Solution &#123; public int maximumLengthSubstring(String s) &#123; //滑动窗口 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; int left = 0; for(int right = 0; right &lt; s.length(); right++) &#123; char ch = s.charAt(right); while(map.getOrDefault(ch, 0) &gt;= 2) &#123; map.merge(s.charAt(left), -1, Integer::sum);//left对应字符个数减少1 left++; &#125; map.merge(ch, 1, Integer::sum); res = Math.max(res, right - left + 1); &#125; return res; &#125;&#125; 知识点Map 接口的 merge 方法允许你在给定的键不存在的情况下插入一个新值，或者当键已经存在时应用合并函数。 1V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) 参数 key: 要插入或更新的键。 value: 如果键不存在，则插入的默认值。 remappingFunction: 如果键已存在，则应用的合并函数。这个函数接受两个参数，一个是当前映射的值，另一个是默认值，并返回一个新的值。 Integer::sum 作为合并函数，这是一个引用 Integer 类的静态方法 sum 的方法引用。Integer::sum 接受两个 int 参数并返回它们的和。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"3.无重复字符的最长子串","path":"/2024/09/14/3-无重复字符的最长子串/","content":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题解123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int n=s.length(); int len=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c = s.charAt(right); while(left&lt;right&amp;&amp;set.contains(c))&#123; //存在相同元素 set.remove(s.charAt(left)); left++; &#125; set.add(c); len=Math.max(len,right-left+1); &#125; return len; &#125;&#125; 知识点滑动窗口模板： 12345678//外层循环扩展右边界，内层循环扩展左边界for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;\t//当前考虑的元素\twhile (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意 //扩展左边界 &#125; //区间[left,right]符合题意，统计相关信息&#125; HashSet： 判断是否有重复的字符。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2653.滑动子数组的美丽值","path":"/2024/09/13/2653-滑动子数组的美丽值/","content":"题目给你一个长度为 n 的整数数组 nums ，请你求出每个长度为 k 的子数组的 美丽值 。 一个子数组的 美丽值 定义为：如果子数组中第 x 小整数 是 负数 ，那么美丽值为第 x 小的数，否则美丽值为 0 。 请你返回一个包含 n - k + 1 个整数的数组，依次 表示数组中从第一个下标开始，每个长度为 k 的子数组的 美丽值 。 子数组指的是数组中一段连续 非空 的元素序列。 示例 1： 123456输入：nums = [1,-1,-3,-2,3], k = 3, x = 2输出：[-1,-2,-2]解释：总共有 3 个 k = 3 的子数组。第一个子数组是 [1, -1, -3] ，第二小的数是负数 -1 。第二个子数组是 [-1, -3, -2] ，第二小的数是负数 -2 。第三个子数组是 [-3, -2, 3] ，第二小的数是负数 -2 。 示例 2： 1234567输入：nums = [-1,-2,-3,-4,-5], k = 2, x = 2输出：[-1,-2,-3,-4]解释：总共有 4 个 k = 2 的子数组。[-1, -2] 中第二小的数是负数 -1 。[-2, -3] 中第二小的数是负数 -2 。[-3, -4] 中第二小的数是负数 -3 。[-4, -5] 中第二小的数是负数 -4 。 示例 3： 12345678输入：nums = [-3,1,2,-3,0,-3], k = 2, x = 1输出：[-3,0,-3,-3,-3]解释：总共有 5 个 k = 2 的子数组。[-3, 1] 中最小的数是负数 -3 。[1, 2] 中最小的数不是负数，所以美丽值为 0 。[2, -3] 中最小的数是负数 -3 。[-3, 0] 中最小的数是负数 -3 。[0, -3] 中最小的数是负数 -3 。 提示： n == nums.length 1 &lt;= n &lt;= 105 1 &lt;= k &lt;= n 1 &lt;= x &lt;= k -50 &lt;= nums[i] &lt;= 50 题解123456789101112131415161718192021222324class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n=nums.length; int[] bn = new int[n-k+1]; int[] count = new int[50*2+1]; for(int i=0;i&lt;k-1;i++)&#123; count[nums[i]+50]++;// 由于nums中的数很小，所以采用计数排序。 &#125; int x1; for(int i=k-1;i&lt;n;i++)&#123; count[nums[i]+50]++; x1=x; for(int j=0;j&lt;50;j++)&#123;// 因为看的是负数，所以只需要遍历负数。 x1-=count[j];// 重点在于这里。 if(x1&lt;=0)&#123; bn[i-(k-1)]=j-50; break; &#125; &#125; count[nums[i-(k-1)]+50]--; &#125; return bn; &#125;&#125; 123456789101112131415161718192021222324252627// 自己开始写的超时了。我的思路是将窗口中的数排序，采用的方法是先转换为列表（因为列表直接添加和删除顺序不变），再由列表转为数组，再采用Arrays.sort()进行排序，取第x个数进行判断。// TODO 暂时还没想到改进方法class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n=nums.length; int[] temp = new int[k]; int[] b = new int[n-k+1]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int count=0; for(int i=0;i&lt;n;i++)&#123; list.add(nums[i]); if(i&lt;k-1)&#123; continue; &#125; temp = list.stream().mapToInt(Integer::intValue).toArray(); Arrays.sort(temp); if(temp[x-1]&lt;0)&#123; b[count]=temp[x-1]; &#125;else&#123; b[count]=0; &#125; count++; list.remove(Integer.valueOf(nums[i-(k-1)])); &#125; return b; &#125;&#125; 知识点滑动窗口 + 计数排序。 思路：在于如何理解第x小的数。 假设第x小的数为num，那么小于num的数的个数肯定小于x，大于num的数的个数肯定大于等于x。两个条件结合才能保证num为第x小的数。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"国内镜像源","path":"/2024/09/13/国内镜像源/","content":"pip常用镜像源清华大学 1https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 1https://mirrors.aliyun.com/pypi/simple/ 网易 1https://mirrors.163.com/pypi/simple/ 豆瓣 1https://pypi.mirrors.ustc.edu.cn/simple/ 中科大 1https://pypi.mirrors.ustc.edu.cn/simple/","categories":["积累"]},{"title":"Anaconda环境创建与卸载","path":"/2024/09/13/Anaconda环境创建与卸载/","content":"环境创建1conda create -n XXX python=3.9 环境删除1conda remove -n XXX --all 环境激活1conda activate XXX 环境查看1conda env list","tags":["Anaconda"],"categories":["技巧"]},{"title":"1423.可获得的最大点数","path":"/2024/09/13/1423-可获得的最大点数/","content":"题目几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 123输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 123输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 123输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 123输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 12输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length 题解12345678910111213141516171819202122232425class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int sum=0; int all=0; int min=Integer.MAX_VALUE; int n=cardPoints.length; int m=n-k;// 新窗口 for(int i=0;i&lt;n;i++) &#123; all += cardPoints[i]; &#125; if(m==0)&#123; return all; &#125;else&#123; for(int i=0;i&lt;n;i++)&#123; sum+=cardPoints[i]; if(i&lt;m-1)&#123; continue; &#125; min = Math.min(min,sum); sum-=cardPoints[i-(m-1)]; &#125; return all-min; &#125; &#125;&#125; 知识点思路：逆向思维。 首先，将问题判断为定长滑动窗口问题：虽然，每次拿牌都可以从开头或者末尾拿一张，总共要拿k张牌。但是，所剩余的牌必定是n-k张（n为牌的总数），且剩余的牌必定是连续的。 然后，要使得拿走的牌点数和最大，那么就意味着剩下的连续牌点数最小。 最后，问题变成求n-k长的子数组和的最小值。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"Hexo博客文档间跳转","path":"/2024/09/12/Hexo博客文档间跳转/","content":"Makdown语法同一目录下，可以这么写： 1[hello-world.Md](hello-world.md) 示例：hello-world.Md Hexo标签使用post_link标签&#123;% post_link 文件名 %&#125;或者&#123;% post_link 文件名 自定义标题 %&#125; 12&#123;% post_link hello-world %&#125;&#123;% post_link hello-world 你好世界 %&#125; 示例：Hello World 你好世界","tags":["Hexo"],"categories":["技巧"]},{"title":"2461.长度为 K 子数组中的最大和","path":"/2024/09/12/2461-长度为-K-子数组中的最大和/","content":"题目给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和： 子数组的长度是 k，且 子数组中的所有元素 各不相同 。 返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。 子数组 是数组中一段连续非空的元素序列。 示例 1： 123456789输入：nums = [1,5,4,2,9,9,9], k = 3输出：15解释：nums 中长度为 3 的子数组是：- [1,5,4] 满足全部条件，和为 10 。- [5,4,2] 满足全部条件，和为 11 。- [4,2,9] 满足全部条件，和为 15 。- [2,9,9] 不满足全部条件，因为元素 9 出现重复。- [9,9,9] 不满足全部条件，因为元素 9 出现重复。因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。 示例 2： 12345输入：nums = [4,4,4], k = 3输出：0解释：nums 中长度为 3 的子数组是：- [4,4,4] 不满足全部条件，因为元素 4 出现重复。因为不存在满足全部条件的子数组，所以返回 0 。 提示： 1 &lt;= k &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 题解1234567891011121314151617181920212223242526272829class Solution &#123; public long maximumSubarraySum(int[] nums, int k) &#123; int n=nums.length; long sum=0; long max=0; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); &#125;else&#123; map.put(nums[i],1); &#125; if(i&lt;k-1)&#123; continue; &#125; if(sum&gt;max &amp;&amp; map.size()==k)&#123; max=sum; &#125; sum-=nums[i-(k-1)]; if(map.get(nums[i-(k-1)])==1)&#123; map.remove(nums[i-(k-1)]); &#125;else&#123; map.put(nums[i-(k-1)],map.get(nums[i-(k-1)])-1); &#125; &#125; return max; &#125;&#125; 知识点和2841.几乎唯一子数组的最大和这篇文章基本一样，只是在更新时，判断有所不一样。 Hello World 你好世界","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2841.几乎唯一子数组的最大和","path":"/2024/09/12/2841-几乎唯一子数组的最大和/","content":"题目给你一个整数数组 nums 和两个正整数 m 和 k 。 请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。 如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。 子数组指的是一个数组中一段连续 非空 的元素序列。 示例 1： 123输入：nums = [2,6,7,3,1,7], m = 3, k = 4输出：18解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。 示例 2： 123输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3输出：23解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。 示例 3： 123输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3输出：0解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。 提示： 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= m &lt;= k &lt;= nums.length 1 &lt;= nums[i] &lt;= 109 题解12345678910111213141516171819202122232425262728293031class Solution &#123; public long maxSum(List&lt;Integer&gt; nums, int m, int k) &#123; HashMap&lt;Integer ,Integer&gt; map = new HashMap&lt;&gt;(); int n=nums.size(); long max=0; long sum=0; // 注意要使用long型，否则越界 for(int i=0;i&lt;n;i++)&#123; sum+=nums.get(i); if(map.containsKey(nums.get(i)))&#123; map.put(nums.get(i),map.get(nums.get(i))+1); &#125;else&#123; map.put(nums.get(i),1); &#125; if(i&lt;k-1)&#123; continue; &#125; // System.out.printlni&quot;map&quot;+map.size()); if(sum&gt;max&amp;&amp;map.size()&gt;=m)&#123; max=sum; &#125; sum-=nums.get(i-(k-1)); if(map.get(nums.get(i-(k-1)))==1)&#123; map.remove(nums.get(i-(k-1))); &#125;else&#123; map.put(nums.get(i-(k-1)),map.get(nums.get(i-(k-1)))-1); &#125; //map.remove(i-(k-1)); &#125; return max; &#125;&#125; 知识点思路：求子数组的 最大和是常规定长滑动窗口问题，这题对我来说难点在于如何判断唯一，我想到使用哈希表，它能保证键唯一。哈希表的键为该位置i的原数组的值，哈希表的值为该值在一个滑动窗口中出现的次数。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1052.爱生气的书店老板","path":"/2024/09/12/1052-爱生气的书店老板/","content":"题目有一个书店老板，他的书店开了 n 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 n 的整数数组 customers ，其中 customers[i] 是在第 i 分钟开始时进入商店的顾客数量，所有这些顾客在第 i 分钟结束后离开。 在某些分钟内，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 minutes 分钟不生气，但却只能使用一次。 请你返回 这一天营业下来，最多有多少客户能够感到满意 。 示例 1： 1234输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 示例 2： 12输入：customers = [1], grumpy = [0], minutes = 1输出：1 提示： n == customers.length == grumpy.length 1 &lt;= minutes &lt;= n &lt;= 2 * 104 0 &lt;= customers[i] &lt;= 1000 grumpy[i] == 0 or 1 题解1234567891011121314151617181920212223242526class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int minutes) &#123; int n=customers.length; int sum=0;// 记录老板不生气时的顾客数量 for(int i=0;i&lt;n;i++)&#123; if(grumpy[i]==0)&#123; sum+=customers[i]; &#125; &#125; int m = 0;// 记录3分钟内老板生气，离开的顾客数量最大值 int ns=0; for(int i=0;i&lt;n;i++)&#123; if(grumpy[i]==1)&#123; ns+=customers[i]; &#125; if(i&lt;minutes-1)&#123; continue; &#125; m = Math.max(m,ns); if(grumpy[i-(minutes-1)]==1)&#123; ns-=customers[i-(minutes-1)]; &#125; &#125; return m+sum; &#125;&#125; 知识点思路：分情况讨论。 所求的是最多有多少客户能够感到满意，包括：1.本来就满意的顾客数量（即，老板不生气时间内的顾客总数）+2.使用密码技巧minutes分钟内，使得本来因老板生气而被赶走的顾客数量。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1652.拆炸弹","path":"/2024/09/11/1652-拆炸弹/","content":"题目你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例 1： 123输入：code = [5,7,1,4], k = 3输出：[12,10,16,13]解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 示例 2： 123输入：code = [1,2,3,4], k = 0输出：[0,0,0,0]解释：当 k 为 0 时，所有数字都被 0 替换。 示例 3： 123输入：code = [2,4,9,3], k = -2输出：[12,5,6,13]解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。 提示： n == code.length 1 &lt;= n &lt;= 100 1 &lt;= code[i] &lt;= 100 -(n - 1) &lt;= k &lt;= n - 1 题解1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[] decrypt(int[] code, int k) &#123; int n=code.length; int[] m = new int[n]; Arrays.fill(m,0); if(k==0)&#123; return m; &#125; int j=0; int sum=0; int count=0;// 记录窗口的数量 if(k&gt;0)&#123; // 窗口位置[1，k]; for(int i=1;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125;else&#123; // 窗口位置[n-k, n-k+k) k=-k; for(int i=n-k;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125; &#125;&#125; 优化：寻找规律，可以发现当k大于0和k小于0时，只有窗口的起始位置不一样。因此，两类可以合并 1234567891011121314151617181920212223242526class Solution &#123; public int[] decrypt(int[] code, int k) &#123; int n=code.length; int[] m = new int[n]; Arrays.fill(m,0); if(k==0)&#123; return m; &#125; int j=0; int sum=0; int count=0; int r = k&gt;0 ? 1 : n+k; k = Math.abs(k); for(int i=r;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125;&#125; 知识点滑动窗口问题，主要考虑窗口大小以及窗口的起始位置。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2379.得到 K 个黑块的最少涂色次数","path":"/2024/09/11/2379-得到-K-个黑块的最少涂色次数/","content":"题目给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 &#39;W&#39; 要么是 &#39;B&#39; ，表示第 i 块的颜色。字符 &#39;W&#39; 和 &#39;B&#39; 分别表示白色和黑色。 给你一个整数 k ，表示想要 连续 黑色块的数目。 每一次操作中，你可以选择一个白色块将它 涂成 黑色块。 请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。 示例 1： 1234567输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7输出：3解释：一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。得到 blocks = &quot;BBBBBBBWBW&quot; 。可以证明无法用少于 3 次操作得到 7 个连续的黑块。所以我们返回 3 。 示例 2： 12345输入：blocks = &quot;WBWBBBW&quot;, k = 2输出：0解释：不需要任何操作，因为已经有 2 个连续的黑块。所以我们返回 0 。 提示： n == blocks.length 1 &lt;= n &lt;= 100 blocks[i] 要么是 &#39;W&#39; ，要么是 &#39;B&#39; 。 1 &lt;= k &lt;= n 题解12345678910111213141516171819202122class Solution &#123; public int minimumRecolors(String blocks, int k) &#123; int n=0; int min= Integer.MAX_VALUE; char[] block = blocks.toCharArray();; for(int i=0;i&lt;block.length;i++)&#123; if(block[i]==&#x27;W&#x27;)&#123; n++; &#125; if(i&lt;k-1)&#123; continue; &#125; if(n&lt;min)&#123; min=n; &#125; if(block[i-(k-1)]==&#x27;W&#x27;)&#123; n--; &#125; &#125; return min; &#125;&#125; 知识点常规滑动窗口","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2090.半径为 k 的子数组平均值","path":"/2024/09/11/2090-半径为-k-的子数组平均值/","content":"题目给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。 半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。 构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。 x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。 例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。 示例 1： 123456789输入：nums = [7,4,3,9,1,8,5,2,6], k = 3输出：[-1,-1,-1,5,4,4,-1,-1,-1]解释：- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。 示例 2： 12345输入：nums = [100000], k = 0输出：[100000]解释：- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。 示例 3： 1234输入：nums = [8], k = 100000输出：[-1]解释：- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。 提示： n == nums.length 1 &lt;= n &lt;= 105 0 &lt;= nums[i], k &lt;= 105 题解12345678910111213141516171819202122232425class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length; int[] avgs = new int[n]; Arrays.fill(avgs,-1); if(n==1&amp;&amp;k==0)&#123; return nums; &#125; if(2*k&gt;=n)&#123; return avgs; &#125; long sum=0;// 防止超限 int j=k; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(i&lt;2*k)&#123; continue; &#125; avgs[j]=(int)(sum/(2*k+1)); j++; sum-=nums[i-(2*k)]; &#125; return avgs; &#125;&#125; 知识点常规定长滑动窗口问题，注意加上坐标中心，同时注意使用long型，否则会超限。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1343.大小为 K 且平均值大于等于阈值的子数组数目","path":"/2024/09/11/1343-大小为-K-且平均值大于等于阈值的子数组数目/","content":"题目给你一个整数数组 arr 和两个整数 k 和 threshold 。 请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。 示例 1： 123输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4输出：3解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。 示例 2： 123输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5输出：6解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。 提示： 1 &lt;= arr.length &lt;= 105 1 &lt;= arr[i] &lt;= 104 1 &lt;= k &lt;= arr.length 0 &lt;= threshold &lt;= 104 题解123456789101112131415161718class Solution &#123; public int numOfSubarrays(int[] arr, int k, int threshold) &#123; int num=0; double sum=0.0; for(int i=0;i&lt;arr.length;i++)&#123; sum+=arr[i]; if(i&lt;k-1)&#123; continue; &#125; if(sum/k&gt;=threshold)&#123; num++; &#125; sum-=arr[i-(k-1)]; &#125; return num; &#125;&#125; 知识点常规滑动窗口问题，无难点。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"643.子数组最大平均数 I","path":"/2024/09/11/643-子数组最大平均数-I/","content":"题目给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。 示例 1： 123输入：nums = [1,12,-5,-6,50,3], k = 4输出：12.75解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 示例 2： 12输入：nums = [5], k = 1输出：5.00000 提示： n == nums.length 1 &lt;= k &lt;= n &lt;= 105 -104 &lt;= nums[i] &lt;= 104 题解1234567891011121314151617181920212223class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; // if(nums.length==1)&#123; // return nums[0]; // &#125; double avg = 0.0; double max=Integer.MIN_VALUE; int sum=0; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; if(i&lt;k-1)&#123; continue; &#125; avg = 1.0*sum/k; if(avg&gt;max)&#123; max = avg; &#125; sum-=nums[i-(k-1)]; &#125; return max; &#125;&#125; 知识点常规的滑动窗口问题，注意考虑特殊情况：最大值的初始化设置 整型最大值：Integer.MAX_VALUE 整型最小值：Integer.MIN_VALUE","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1456.定长子串中元音的最大数目","path":"/2024/09/10/1456-定长子串中元音的最大数目/","content":"题目给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例 1： 123输入：s = &quot;abciiidef&quot;, k = 3输出：3解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。 示例 2： 123输入：s = &quot;aeiou&quot;, k = 2输出：2解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 123输入：s = &quot;leetcode&quot;, k = 3输出：2解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。 示例 4： 123输入：s = &quot;rhythms&quot;, k = 4输出：0解释：字符串 s 中不含任何元音字母。 示例 5： 12输入：s = &quot;tryhard&quot;, k = 4输出：1 提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length 题解123456789101112131415161718192021222324252627class Solution &#123; public int maxVowels(String S, int k) &#123; char[] s = S.toCharArray(); int max=0; int v=0; for(int i=0;i&lt;s.length;i++)&#123; // 进入窗口 if(s[i]==&#x27;a&#x27;||s[i] == &#x27;e&#x27; || s[i] == &#x27;i&#x27; || s[i] == &#x27;o&#x27; || s[i] == &#x27;u&#x27;)&#123; v++; &#125; // 未到窗口大小 if(i&lt;k-1)&#123; continue; &#125; // 更新 if(v&gt;max)&#123; max=v; &#125; // 出 char out = s[i-(k-1)]; if (out == &#x27;a&#x27; || out == &#x27;e&#x27; || out == &#x27;i&#x27; || out == &#x27;o&#x27; || out == &#x27;u&#x27;) &#123; v--; &#125; &#125; return max; &#125;&#125; 知识点三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果 i &lt; k−1 则重复第一步。更新：更新答案。一般是更新最大值&#x2F;最小值。出：下标为 i − (k-1) 的元素离开窗口，更新相关统计量。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2552.统计上升四元组（题解都看不懂，害）","path":"/2024/09/10/2552-统计上升四元组/","content":"题目给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。 如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的： 0 &lt;= i &lt; j &lt; k &lt; l &lt; n 且 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。 示例 1： 123456输入：nums = [1,3,2,4,5]输出：2解释：- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。没有其他的四元组，所以我们返回 2 。 示例 2： 123输入：nums = [1,2,3,4]输出：0解释：只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。 提示： 4 &lt;= nums.length &lt;= 4000 1 &lt;= nums[i] &lt;= nums.length nums 中所有数字 互不相同 ，nums 是一个排列。 代码知识点"},{"title":"bat批处理脚本自动部署Hexo博客","path":"/2024/09/10/bat批处理脚本自动部署Hexo博客/","content":"原因每次提交博客，都需要进行hexo clean hexo g hexo d指令，十分繁琐 优点Windows中的.bat文件可以直接点击运行，同时还能把多条指令写进一个.bat文件。 代码1234@echo offD:cd D:\\bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo d 指令说明@echo off，关闭回显。D:，切换到博客站点目录所在的盘符cd D:\\blog，进入站点目录hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，清理缓存和部署目录，生成最新的静态文件，部署新生成的静态文件。","tags":["Hexo","自动部署"],"categories":["脚本"]},{"title":"49.字母异位词分组","path":"/2024/09/10/49-字母异位词分组/","content":"题目给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 示例 1: 12输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 示例 2: 12输入: strs = [&quot;&quot;]输出: [[&quot;&quot;]] 示例 3: 12输入: strs = [&quot;a&quot;]输出: [[&quot;a&quot;]] 提示： 1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i] 仅包含小写字母 题解思路：字母异位词的两个字符串的字母相同，仅是顺序不一样。因此，通过排序得到的字符串肯定一样。可以通过哈希表来存储，其中键为排序后的字符串，值为该组异位字符词。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); List&lt;String&gt; list; for (String str : strs) &#123;// 遍历 char[] array = str.toCharArray();// 字符串转字符数组 Arrays.sort(array);// 对字符数组排序 String key = new String(array); if(map.containsKey(key)==true)&#123; list = map.get(key); &#125;else&#123; list = new ArrayList&lt;String&gt;(); &#125; //List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());// map中存在该key，则使用该key对应的value，否则为空List list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 知识点HashMap方法 定义：Map&lt;String ,String&gt; map = new HashMap&lt;String ,String&gt;(); 添加键值对：put(Object key, Object value); 获取映射值：getOrDefault(Object key, V defaultValue); 是否有指定key的映射：boolean containsKey(Object key); String 类方法 字符串转换成字符数组：str.toCharArray(); Arrays类方法 对数组进行排序：Arrays.sort();","tags":["HashMap"],"categories":["LeetCode"]},{"title":"这是文章标题","path":"/2024/08/16/20240114/","content":"文章正文"},{"title":"Hello World","path":"/2024/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418:root&#123; --code-autor: &#x27;© 钟意博客🌙&#x27;; --code-tip: &quot;优雅借鉴&quot;;&#125; /*语法高亮*/ .hljs &#123; position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) &#125; .hljs::before &#123; content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 &#125; .highlight:hover .hljs::before &#123; color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; &#125; .hljs-ln &#123; display: inline-block; overflow-x: auto; padding-bottom: 5px &#125; .hljs-ln td &#123; padding: 0; background-color: var(--block) &#125; .hljs-ln::-webkit-scrollbar &#123; height: 10px; border-radius: 5px; background: #333; &#125; .hljs-ln::-webkit-scrollbar-thumb &#123; background-color: #bbb; border-radius: 5px; &#125; .hljs-ln::-webkit-scrollbar-thumb:hover &#123; background: #ddd; &#125; .hljs table tbody tr &#123; border: none &#125; .hljs .hljs-ln-line &#123; padding: 1px 10px; border: none &#125; td.hljs-ln-line.hljs-ln-numbers &#123; border-right: 1px solid #666; &#125; .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name &#123; color: #c78300 &#125; .hljs-link &#123; color: #569cd6; text-decoration: underline &#125; .hljs-built_in, .hljs-type &#123; color: #4ec9b0 &#125; .hljs-number, .hljs-class &#123; color: #2094f3 &#125; .hljs-string, .hljs-meta-string &#123; color: #4caf50 &#125; .hljs-regexp, .hljs-template-tag &#123; color: #9a5334 &#125; .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula &#123; color: #c78300 &#125; .hljs-property &#123; color: #9c67a1; &#125; .hljs-comment, .hljs-quote &#123; color: #57a64a; font-style: italic &#125; .hljs-doctag &#123; color: #608b4e &#125; .hljs-meta, .hljs-meta-keyword, .hljs-tag &#123; color: #9b9b9b &#125; .hljs-variable, .hljs-template-variable &#123; color: #bd63c5 &#125; .hljs-attr, .hljs-attribute, .hljs-builtin-name &#123; color: #d34141 &#125; .hljs-section &#123; color: gold &#125; .hljs-emphasis &#123; font-style: italic &#125; .hljs-strong &#123; font-weight: bold &#125; .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo &#123; color: #c78300 &#125; .hljs-addition &#123; background-color: #144212; display: inline-block; width: 100% &#125; .hljs-deletion &#123; background-color: #600; display: inline-block; width: 100% &#125; .hljs.language-html::before, .hljs.language-xml::before &#123; content: &quot;HTML/XML&quot; &#125; .hljs.language-javascript::before &#123; content: &quot;JavaScript&quot; &#125; .hljs.language-c::before &#123; content: &quot;C&quot; &#125; .hljs.language-cpp::before &#123; content: &quot;C++&quot; &#125; .hljs.language-java::before &#123; content: &quot;Java&quot; &#125; .hljs.language-asp::before &#123; content: &quot;ASP&quot; &#125; .hljs.language-actionscript::before &#123; content: &quot;ActionScript/Flash/Flex&quot; &#125; .hljs.language-bash::before &#123; content: &quot;Bash&quot; &#125; .hljs.language-css::before &#123; content: &quot;CSS&quot; &#125; .hljs.language-asp::before &#123; content: &quot;ASP&quot; &#125; .hljs.language-cs::before, .hljs.language-csharp::before &#123; content: &quot;C#&quot; &#125; .hljs.language-d::before &#123; content: &quot;D&quot; &#125; .hljs.language-golang::before, .hljs.language-go::before &#123; content: &quot;Go&quot; &#125; .hljs.language-json::before &#123; content: &quot;JSON&quot; &#125; .hljs.language-lua::before &#123; content: &quot;Lua&quot; &#125; .hljs.language-less::before &#123; content: &quot;LESS&quot; &#125; .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before &#123; content: &quot;Markdown&quot; &#125; .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before &#123; content: &quot;Objective-C&quot; &#125; .hljs.language-php::before &#123; content: &quot;PHP&quot; &#125; .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before &#123; content: &quot;Perl&quot; &#125; .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before &#123; content: &quot;Python&quot; &#125; .hljs.language-r::before &#123; content: &quot;R&quot; &#125; .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before &#123; content: &quot;Ruby&quot; &#125; .hljs.language-sql::before &#123; content: &quot;SQL&quot; &#125; .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before &#123; content: &quot;Shell&quot; &#125; .hljs.language-swift::before &#123; content: &quot;Swift&quot; &#125; .hljs.language-vb::before &#123; content: &quot;VB/VBScript&quot; &#125; .hljs.language-yaml::before &#123; content: &quot;YAML&quot; &#125; /*stellar主题补偿*/ .md-text pre&gt;.hljs &#123; padding-top: 2rem !important; &#125; .md-text pre &#123; padding: 0 !important; &#125; code &#123; background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; background-size: 20px 20px !important; background-position: 50% !important; &#125; figure::after &#123; content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 &#125; figcaption span &#123; border-radius: 0px 0px 12px 12px !important; &#125; /* 复制代码按钮 */ .highlight &#123; position: relative; &#125; .highlight .code .copy-btn &#123; position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; &#125; .highlight .code .copy-btn:hover &#123; color: var(--text-code); opacity: 0.75; &#125; .highlight .code .copy-btn.success &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; /* 描述 */ .md-text .highlight figcaption span &#123; font-size: small; &#125; /* 折叠 */ code.hljs &#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; /*-webkit-line-clamp: 6;*/ padding: 1rem 1rem 0 1rem; /* chino建议 */ &#125; .hljsOpen &#123; -webkit-line-clamp: 99999 !important; &#125; .CodeCloseDiv &#123; color: #999; background: var(--block); display: flex; justify-content: center; margin-top: inherit; margin-bottom: -18px; &#125; .CodeClose &#123; color: #999; margin-top: 3px; background: var(--block); &#125; .highlight button:hover, .highlight table:hover+button &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; More info: Deployment"},{"path":"/more/index.html","content":"我的订阅我的歌单关于本站关于博主 .md-text .tag-plugin.timeline .timenode>.body, .md-text .tag-plugin.timeline .timenode>.header { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }"},{"path":"/notes/index.html","content":"zh吱吱吱吱"},{"title":"测试","path":"/notes/test.html","content":"测试 11111111111111"},{"title":"测试2","path":"/notes/test2.html","content":"测试2 2222222222"},{"path":"/share/index.html","content":"2024 2024-03-09狠人必备：陈桂林同款手表🐷2024-02-18自制多肉拼盘🌱2024-02-13哦🫨，啊😮，哇😍 Your browser does not support the video tag. 2024-02-13彩菊的正确打开方式😎 Your browser does not support the video tag. 2024-02-13落日余晖 &amp; 皓月当空🌆2024-02-13南京青奥中心🏙️2024-02-11草莓园里摘草莓🍓2024-02-07过年就是要放烟花🎇2024-02-07夕阳下雪白的田野⛄"},{"path":"/more/about/index.html","content":"我的订阅我的歌单关于本站关于博主 这里是瓦豆鲁迪的个人站点。我在这里记录生活的点滴与感悟，也在这里分享和技术相关的内容。希望我的内容对您有所帮助，如果您有任何想法或问题，欢迎在评论区留言。 站点信息 本站使用 Hexo 框架和 Stellar 主题创建，代码托管于 GitHub，站点部署于 Vercel。 评论系统使用 Waline 创建，系统部署于 Vercel，数据存储于 LeanCloud。 订阅系统使用 友链朋友圈 创建，系统部署于 Vercel，数据存储于 GitHub。 隐私声明 本站非常重视您的隐私及数据安全，在访问本站时，不会收集和存储您的任何数据。 在使用本站评论系统时，会收集和存储您的相关信息，详见 Waline 隐私声明。 本站仅会使用您的信息来提供评论服务，并且尽最大努力保护您的隐私及数据安全。 版权声明 本站所有内容均采用 署名-非商业性使用-禁止演绎 4.0 国际 许可协议，未经授权请勿转载。 本站所有内容均由本人亲自撰写，没有使用任何人工智能生成技术。 免责声明 本站所有内容不代表任何组织的立场和意见，也不构成任何形式的建议或指导。 本站对内容的真实性、完整性、准确性和及时性不作任何保证，也不承担任何法律责任。"},{"path":"/js/services/txmap.js","content":"//get请求 $.ajax({ type: 'get', url: 'https://apis.map.qq.com/ws/location/v1/ip', data: { key: 'XRWBZ-J436B-NOKU3-JPDTY-AWCIH-SXF7X', output: 'jsonp', }, dataType: 'jsonp', success: function (res) { ipLoacation = res; } }) function getDistance(e1, n1, e2, n2) { const R = 6371 const { sin, cos, asin, PI, hypot } = Math let getPoint = (e, n) => { e *= PI / 180 n *= PI / 180 return { x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) } } let a = getPoint(e1, n1) let b = getPoint(e2, n2) let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z) let r = asin(c / 2) * 2 * R return Math.round(r); } function showWelcome() { console.log(ipLoacation) let dist = getDistance(107.754444, 31.148725, ipLoacation.result.location.lng, ipLoacation.result.location.lat); //这里换成自己的经纬度 let pos = ipLoacation.result.ad_info.nation; let ip; let posdesc; //根据国家、省份、城市信息自定义欢迎语 switch (ipLoacation.result.ad_info.nation) { case \"日本\": posdesc = \"よろしく，一起去看樱花吗\"; break; case \"美国\": posdesc = \"Let us live in peace!\"; break; case \"英国\": posdesc = \"想同你一起夜乘伦敦眼\"; break; case \"俄罗斯\": posdesc = \"干了这瓶伏特加！\"; break; case \"法国\": posdesc = \"C'est La Vie\"; break; case \"德国\": posdesc = \"Die Zeit verging im Fluge.\"; break; case \"澳大利亚\": posdesc = \"一起去大堡礁吧！\"; break; case \"加拿大\": posdesc = \"拾起一片枫叶赠予你\"; break; case \"中国\": pos = ipLoacation.result.ad_info.province + \" \" + ipLoacation.result.ad_info.city + \" \" + ipLoacation.result.ad_info.district; ip = ipLoacation.result.ip; switch (ipLoacation.result.ad_info.province) { case \"北京市\": posdesc = \"北——京——欢迎你~~~\"; break; case \"天津市\": posdesc = \"讲段相声吧。\"; break; case \"河北省\": posdesc = \"山势巍巍成壁垒，天下雄关。铁马金戈由此向，无限江山。\"; break; case \"山西省\": posdesc = \"展开坐具长三尺，已占山河五百余。\"; break; case \"内蒙古自治区\": posdesc = \"天苍苍，野茫茫，风吹草低见牛羊。\"; break; case \"辽宁省\": posdesc = \"我想吃烤鸡架！\"; break; case \"吉林省\": posdesc = \"状元阁就是东北烧烤之王。\"; break; case \"黑龙江省\": posdesc = \"很喜欢哈尔滨大剧院。\"; break; case \"上海市\": posdesc = \"众所周知，中国只有两个城市。\"; break; case \"江苏省\": switch (ipLoacation.result.ad_info.city) { case \"南京市\": posdesc = \"这是我挺想去的城市啦。\"; break; case \"苏州市\": posdesc = \"上有天堂，下有苏杭。\"; break; default: posdesc = \"散装是必须要散装的。\"; break; } break; case \"浙江省\": posdesc = \"东风渐绿西湖柳，雁已还人未南归。\"; break; case \"河南省\": switch (ipLoacation.result.ad_info.city) { case \"郑州市\": posdesc = \"豫州之域，天地之中。\"; break; case \"南阳市\": posdesc = \"臣本布衣，躬耕于南阳。此南阳非彼南阳！\"; break; case \"驻马店市\": posdesc = \"峰峰有奇石，石石挟仙气。嵖岈山的花很美哦！\"; break; case \"开封市\": posdesc = \"刚正不阿包青天。\"; break; case \"洛阳市\": posdesc = \"洛阳牡丹甲天下。\"; break; default: posdesc = \"可否带我品尝河南烩面啦？\"; break; } break; case \"安徽省\": posdesc = \"蚌埠住了，芜湖起飞。\"; break; case \"福建省\": posdesc = \"井邑白云间，岩城远带山。\"; break; case \"江西省\": posdesc = \"落霞与孤鹜齐飞，秋水共长天一色。\"; break; case \"山东省\": posdesc = \"遥望齐州九点烟，一泓海水杯中泻。\"; break; case \"湖北省\": posdesc = \"来碗热干面！\"; break; case \"湖南省\": posdesc = \"74751，长沙斯塔克。\"; break; case \"广东省\": posdesc = \"老板来两斤福建人。\"; break; case \"广西壮族自治区\": posdesc = \"桂林山水甲天下。\"; break; case \"海南省\": posdesc = \"朝观日出逐白浪，夕看云起收霞光。\"; break; case \"四川省\": posdesc = \"康康川妹子。\"; break; case \"贵州省\": posdesc = \"茅台，学生，再塞200。\"; break; case \"云南省\": posdesc = \"玉龙飞舞云缠绕，万仞冰川直耸天。\"; break; case \"西藏自治区\": posdesc = \"躺在茫茫草原上，仰望蓝天。\"; break; case \"陕西省\": posdesc = \"来份臊子面加馍。\"; break; case \"甘肃省\": posdesc = \"羌笛何须怨杨柳，春风不度玉门关。\"; break; case \"青海省\": posdesc = \"牛肉干和老酸奶都好好吃。\"; break; case \"宁夏回族自治区\": posdesc = \"大漠孤烟直，长河落日圆。\"; break; case \"新疆维吾尔自治区\": posdesc = \"驼铃古道丝绸路，胡马犹闻唐汉风。\"; break; case \"台湾省\": posdesc = \"我在这头，大陆在那头。\"; break; case \"香港特别行政区\": posdesc = \"永定贼有残留地鬼嚎，迎击光非岁玉。\"; break; case \"澳门特别行政区\": posdesc = \"性感荷官，在线发牌。\"; break; default: posdesc = \"带我去你的城市逛逛吧！\"; break; } break; default: posdesc = \"带我去你的国家逛逛吧。\"; break; } //根据本地时间切换欢迎语 let timeChange; let date = new Date(); if (date.getHours() >= 5 && date.getHours() < 11) timeChange = \"上午好，一日之计在于晨！\"; else if (date.getHours() >= 11 && date.getHours() < 13) timeChange = \"中午好，该摸鱼吃午饭了。\"; else if (date.getHours() >= 13 && date.getHours() < 15) timeChange = \"下午好，懒懒地睡个午觉吧！\"; else if (date.getHours() >= 15 && date.getHours() < 16) timeChange = \"三点几啦，一起饮茶呀！\"; else if (date.getHours() >= 16 && date.getHours() < 19) timeChange = \"夕阳无限好！\"; else if (date.getHours() >= 19 && date.getHours() < 24) timeChange = \"晚上好，夜生活嗨起来！\"; else timeChange = \"夜深了，早点休息，少熬夜。\"; try { //自定义文本和需要放的位置 document.getElementById(\"welcome-info\").innerHTML = `欢迎来自 ${pos} 的小伙伴，${timeChange}您现在距离站长约 ${dist} 公里， ${posdesc} `; } catch (err) { // console.log(\"Pjax无法获取#welcome-info元素🙄🙄🙄\") } } window.onload = showWelcome; // 如果使用了pjax在加上下面这行代码 document.addEventListener('pjax:complete', showWelcome);"},{"path":"/more/me/index.html","content":"我的订阅我的歌单关于本站关于博主 我的职业目前是一名 IT 系统工程师，毕业之后开始专注微软技术。从操作系统 Windows Server 和虚拟化技术 Hyper-V，到统一通信平台 Exchange、Lync、SharePoint Server，再到 System Center、Dynamics Server 系列产品，一路追随微软的脚步成长。最近几年，随着云计算与低代码的日益发展，也先后熟悉了 Azure、Power Platform 等平台。我当下的目标是成为一名微软技术顾问。 人格类型 测试结果来自 16Personalities。 我的游戏 联系方式 Emailmailto:parasol@waddledee.com Telegramhttps://t.me/parasolwaddledee"},{"title":"这是分页标题","path":"/wiki/hexo-stellar/index.html","content":"z是stellar"},{"path":"/more/music/index.html","content":"我的订阅我的歌单关于本站关于博主"},{"title":"测试","path":"/wiki/hexo-stellar/test.html","content":"帆帆帆帆帆帆帆帆。为什么没有啊"}]