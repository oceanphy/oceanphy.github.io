[{"title":"Visio 2019 专业版 下载安装","path":"/2024/10/28/Visio-2019-专业版-下载安装/","content":"软件下载使用微软官网给的下载地址。 简体中文版：http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img 软件安装双击打开（或解压）文件 右键以管理员身份运行 软件激活方法一：使用激活码 方法二： 非官方下载激活工具：https://github.com/oceanphy/activation-tools.git解压.7z文件运行Keygen程序，点击开始即可","tags":["软件下载"],"categories":["积累"]},{"title":"论文写作","path":"/2024/10/22/论文写作/","content":"学术论文基本概念学术论文是对研究工作的阶段性总结，创新点只需要一两个就足够发表，不需要华丽的文采，但要将正确的内容放在正确的位置，需要有清晰的结构：引言、文献综述、研究方法、实验结果、讨论和结论等部分。 论文并不是想怎么写就怎么写的，需要按照模板写。模板是通过阅读文献（建议读顶刊（打磨得更好），顶会），自己总结而来的；也可以使用别人总结的模板（自己实验室相关方向）。 论文结构题目要有吸引力（新问题、新方法），但是要便于理解（应使用领域内常用词汇）、易于检索。 长度控制在40-60个字母之间（越短越创新，越长范围越窄）。 尽量不使用based on（烂大街）。 使用through、with等来表示技术。 题目可以写上算法的缩写。 摘要只写十句话，以下是八股结构： 问题及其重要性：说明问题所属的领域，解释最重要的概念，或者强调问题的重要性。 已有工作：描述该问题的流行解决方案。 已有工作局限性：以However开头，但不要批得太狠。本句挖坑，但不要挖太大确保能填上。 本文工作：以In this paper开始，出现算法的缩写。 之后用三句话介绍本文工作的3 个技术&#x2F;步骤&#x2F;方面&#x2F;优势&#x2F;贡献。 实验设置：给出数据来源等。 实验结果：提高了效率、准确率等（有时候会要求写详细点）。 提升：吹自己的论文有何意义。 关键词关键词是摘要的补充，一般需要3-5个关键词，每个关键词1-3个单词，关键词按照字母顺序排列。 引言讲述完整故事。 引言很重要，很多审稿人在读完引言后, 就有了基本 （80% 以上）的判断。 引言可以看作摘要的扩展（因此，摘要更要写好），即将摘要的每句话扩展成一段话。其中，每段应该有5-10句，同时不要让段落太长或太短。 流行在引言中放一张图，该图可以展现核心技术、算法框架、小的运行实例、效果对比等等。采用这种风格，应该围绕图来介绍，帮助读者更快理解论文主要内容。注意：图画好了, 可以加分; 画不好的话, 还不如不要。 文献综述每篇所引用的论文都应该有文献综述。 在引言中引用得比较简略，在相关工作中详细引用。 文献应该分类，而不是全句引用。 参考文献的引用不能作为句子的主语和宾语。 合理评价相关工作的优缺点：优点使劲夸，说缺点要中肯。 理论部分理论要完备，符号风格要一致。 重要结论叫定理（theorem），方便定理理解的叫引理（lemma），对定理进一步推导的叫推论（corollary）。 算法伪代码需要说明输入、输出 需要对主要步骤进行注释 长度控制在15-30行 可引用数学式子 同时一般还需要对算法进行时间、空间复杂度分析 实验实验占据一篇论文的大半篇幅。 需要介绍实验设置相关信息，如：所用数据集（来源、大小等重要信息）、实验相关参数设置（方便复现）以及所用设备信息。 实验部分主要是为了回答作者和读者关心的问题，所以可以采取一种比较八股的方法：自问自答。即，在实验这部分开始，可以提出问题，当展示完实验结果后，一一回答这些问题。 实验是为了通过对比来展示自己算法的优越性，因此，要挑选表现好的结果进行展示（注意：而不是修改实验数据）。 常见的对比方法，可以分为内部：通过参数的变化来说明性能的变化；可以分为外部：通过本算法与经典方法、基准方法和最先进的方法进行比较。 注意： 对于实验结果应该有详细的分析； 并不需要在所有数据上都最优； 除了分析自己算法的优势，还应分析它的劣势。 结论不需要太长，一般5句话。当想写的内容较多时，可以在结论这部分之前单独加一节Discussions。 虽然结论一般和摘要讲的内容差不多，但是要避免与摘要的句子重复。结论相比于摘要更具体，当摘要中写做了某事，结论中可以写通过这些事，得到了什么效果。 建议可以额外讨论进一步工作，因为可以按照这个思路进行进一步研究。（这样有可能就提高了引用量） 参考文献注意！！！不要直接使用网上的 bibitem。 写参考文献实际上是进行填表，即：使用以下模板，将引用的论文的信息填写进去： 12345678910111213141516171819@ARTICLE&#123;MinZhang2020Frequent, author = &#123;Fan Min and Zhi-Heng Zhang and Wen-Jie Zhai and Rong-Ping Shen&#125;, title = &#123;Frequent pattern discovery with tri-partition alphabets&#125;, journal = &#123;Information Sciences&#125;, year = &#123;2020&#125;, volume = &#123;507&#125;, number = &#123;1&#125;, pages = &#123;715--732&#125;, doi = &#123;10.1016/j.ins.2018.04.013&#125;&#125;@INPROCEEDINGS&#123;MinCai2007Dynamic, author = &#123;Fan Min and Hong-Bin Cai and Qi-He Liu and Zhong-Jian Bai&#125;, title = &#123;Dynamic discretization: a combination approach&#125;, booktitle = &#123;Proc. ICMLC&#125;, year = &#123;2007&#125;, pages = &#123;3672--3677&#125;&#125; 注意事项论文写作工具只建议使用Latex，虽然需要写代码，但是容易上手。重要的是格式调整非常方便。本科写毕业论文，经常调整一个地方的格式，导致所有格式都乱了。 而且，每个期刊都会提供格式文件，格式修改非常方便。而且，网上有许多模板文件，通常只需要将对应位置替换为自己论文内容，稍作修改，就能得到一篇新的文章。 Latex格式不用重头写，最好是找已经被该期刊录用的论文的源文件，或者是找该期刊提供的模板文件。 cls文件：用于控制论文的总体格式 bst文件：用于控制参考文献的格式 尽量避免使用\\usepackage导入包，以免不兼容，导致期刊投稿网站上无法运行。 慎用的单词与词语一般而言，未在任何学术论文中出现的单词，严禁使用。 可以使用linggle网站，来查询单词和词汇的使用频率，一般选择使用频率高的的词。作为初学者，尤其要注意是否滥用某词，所以需要全篇自查。 论文属于正式文章，所以通常不使用缩写，即应使用have not, do not, cannot等。仅当使用authors’之类的情况，才使用撇号。 禁止在句子开头使用And（相邻句子本身就具有相关性，使用And毫无意义），句中慎用and（因为从语义上可能无法并列）； 禁用Easy（简单的东西就没研究价值）； 慎用Simple（与easy类似。可以使用simple yet effective）； 慎用Solve（彻底解决某个难题, 写出了相应的定理与证明，才能使用solve。一般使用handle或address）； 慎用Novel（视工作创新性而定，一般的话使用new，投顶刊顶会使用novel）； Only靠后使用（consider only uniform distribution 而不是 only consider uniform distribution，表达自己有某个能力，而没有做）； 慎用Prove（实验结果通常只能show，仅当写了定理、性质及其证明过程, 才能说 prove）。 解决英文句子语法问题好的中文 &#x3D; 好的英文。 句子的背后都是正确的逻辑。 可以使用charGPT来润色句子（注意专业术语），但不要用来生成句子。 两种方法写出好的句子： 借鉴法（推荐使用）基本步骤： 寻找相关方向的顶刊论文（打磨得更好）。 找出各部分的简单句子。 得到句型 注意事项： 按照一定的方式（句子基本结构，出现的介词，出现的位置等）来分别总结（方便查找和使用）。 不要使用从句（复杂句式），不便于理解。 优缺点： 优点：写的句子基本没有语法错误，使用总结的句式也很快。 缺点：需要积累很多句式，建议第一篇论文先花一周总结两百多个句式。 倒腾法基本步骤： 写一个英文句子。 使用翻译网站（百度、谷歌）翻译成中文。 再翻译成英文，直到中英文句子都不再改变。 再将剧中的非专业词汇替换为正确的专业词汇。 注意事项： 最好从英文句子开始。 如果最终的句子和最初写的句子相差太大，且没有正确表达想要表达的意思，需要根据最初的句子对最终的句子进行修改。 优缺点： 优点：可以按照自己的意思来写。 缺点：中文表达可能很差，导致最终句子还是不合格，很花时间。 符号系统不要对论文中的公式、符号进行额外的、特殊的处理。 严禁在word中使用公式编辑器编写公式，再转到Latex中。 注意一篇论文符号系统的一致性，不要出现一个符号代表两种意思的情况。 不同字体的同一个字母表示不同的涵义。 一个公式有编号就能使用（通过交叉引用）。 数学表达式太长，应将它进行切分。 文字中的数值均使用 $$ 括起来，与纯文字有点差别。 使用千分位 (1&#x2F;4 空格 \\,) 的作用: $123\\,456.789\\,01$ 的效果如下：$$123,456.789,01$$数值与单位之间也使用千分位分开, 且单位用正体. 如: $35$\\,m, $20$\\,kg 可以通过已发表论文中的tex文件来学习数学表达式。 图使用矢量图，可以使用Visio和Inkscape绘制。","tags":["论文写作"],"categories":["课程"]},{"title":"论文略读","path":"/2024/10/22/论文略读/","content":"Wings: Efficient Online Multiple Graph Pattern Matching实现了一个分布式系统，用于在线多图模式匹配。 采用有向无环图（DAG）来解决查询优化问题（许多查询图可能都有相同的查询子图，导致出现重复计算），从DAG中生成最优的查询计划。DAG中的节点是多个查询的子图模式。 采用渐进策略来进一步修剪DAG，用以评估查询路径的成本。 采用小批量的深度优先查询执行策略，来解决仍可能在匹配阶段才出现的重复匹配，导致产生大量中间结果，导致内存占用高。 这篇论文介绍了一个名为Wings的分布式系统，旨在解决在线多图模式匹配（online multi-GPM）问题。这个问题在需要对动态变化的图数据进行实时分析的应用程序中非常重要，例如在电子商务网站、社交网络公司和投资银行等领域。在线多GPM的挑战在于它需要快速响应以便于及时的业务决策。 提出的问题： 现有的图模式匹配（GPM）方法主要集中在两个方面：一是寻找单个查询模式，二是在静态图上寻找模式。然而，许多现代应用需要匹配多个查询模式，并且这些模式是在不断变化的图上进行匹配的。这就需要一个系统能够快速响应，以便及时做出业务决策。 解决方案： Wings系统通过一个查询规划器来优化查询计划，该规划器通过最大化多个查询之间的计算共享，并最小化中间匹配结果来实现高效的多GPM。此外，论文还设计了一个高效的查询执行器，具有内存占用控制和运行时冗余处理消除功能。 实现方法： 查询规划器： 通过构建一个有向无环图（DAG），其中节点代表多个查询的子图模式，然后生成一个集成的最优查询计划，以实现查询间的计算共享并避免重复匹配。 查询执行器： 采用minibatch深度优先查询执行策略，以限制内存占用，并动态识别和消除查询执行过程中的冗余处理。 具体实现： DAG构建： 通过算法构建DAG，包括最大子图（MS）节点和最大公共子图（MCS）节点，以考虑不同的匹配顺序和计算共享。 成本估计和DAG剪枝： 使用一种渐进策略，通过快速剪枝DAG来减少成本估计和计划优化的时间。 最优计划近似： 使用近似算法来解决DAG上的定向斯坦纳树问题（DST），以找到最优查询计划。 实验部分： 实验部分通过与现有的系统（如TigerGraph和Timely Dataflow）进行比较，验证了Wings设计的有效性。实验在10台机器的集群上进行，使用了四个流行的数据图，包括LSBench、LiveJournal、Twitter和WebUK。实验评估了Wings的查询计划优化方法的有效性、查询执行的效率，并与其他基线进行了比较。 对比： Wings与现有的单查询GPM优化算法（如SymBi）和多查询处理方法（如TRIC）进行了比较。实验结果表明，Wings在查询计划优化和查询执行方面都优于现有方法。 Time-Constrained Continuous Subgraph Matching Using Temporal Information for Filtering and Backtracking提出了一种过滤技术和修剪技术，用于时间约束下的连续子图匹配。（即在时间数据图上找到与时间查询图同构且满足时间查询图顺序的所有匹配）。 这篇论文提出了一种新的算法，用于解决时间约束的连续子图匹配（time-constrained continuous subgraph matching）问题。这个问题在实时分析包含时序信息的图数据中非常重要，例如社交媒体流、问答网络和网络数据源等。算法的目标是在时间变化的数据图中，实时检测具有严格部分顺序模式的子图。 问题背景： 现实世界中的图数据（如社交网络、金融交易网络）包含时序信息，称为时序图。 时间约束的连续子图匹配问题旨在实时检测与查询图在拓扑结构和时间顺序上都同构的子图。 提出的方法： 时间约束可匹配边（TC-matchable edge）：这是一种过滤技术，利用时序信息在多项式空间内进行过滤。 时间约束剪枝（time-constrained pruning）：在回溯过程中，通过利用时序信息减少搜索空间，剪枝一些平行边。 具体实现： 论文提出了一个基于上述两种技术的算法，称为TCM（Time-Constrained Continuous Subgraph Matching）。 为了提高过滤效率，论文引入了一种名为max-min时间戳的数据结构，可以高效地确定边是否被时间约束可匹配边过滤，并能随着图的更新而更新。 论文还开发了一套时间约束剪枝技术，通过考虑平行边之间的时间关系来减少回溯过程中的搜索空间。 实验部分： 作者在真实和合成数据集上进行了广泛的实验，包括Netflow、Wiki-talk、Superuser、StackOverflow、Yahoo和LSBench。 实验结果表明，TCM算法在查询处理时间上比现有最先进的算法快两个数量级。 论文还比较了算法在不同查询大小、时间顺序密度和时间窗口大小下的性能。 对比分析： 论文将TCM算法与现有的算法（如Timing和Hasse）进行了比较。 通过实验数据，展示了TCM在不同场景下的性能优势，包括处理时间和内存使用。 未来研究方向： 论文提出，未来的工作可以探索算法的并行化，以进一步提高处理大规模图数据的效率。 总的来说，这篇论文针对实时图数据分析中的时间约束子图匹配问题，提出了一种新的高效算法，并通过实验验证了其优越的性能。论文还指出了未来可能的研究方向，包括算法的并行化。 Search to Fine-tune Pre-trained Graph Neural Networks for Graph-level Tasks提出内容： 这篇论文提出了S2PGNN框架，旨在自动化搜索适合给定预训练图神经网络（GNNs）和下游图数据集的微调策略。 解决的问题： S2PGNN旨在解决预训练GNNs在下游任务中微调策略设计不足的问题，尤其是现有方法要么假设过强，要么忽视了不同下游数据集的数据感知需求。 采用的方法： S2PGNN通过定义一个新颖的微调策略搜索空间，并集成了一个高效的搜索算法来探索最佳微调策略。该算法结合了参数共享和连续松弛技术，并通过可微分优化解决问题。 具体实现： 具体实现涉及构建一个双级优化问题，外层优化寻找最佳微调策略，内层优化在给定策略下训练模型参数。搜索空间包括多个设计维度，如背骨卷积、身份增强、多尺度融合和图级读出。通过梯度下降方法优化一个参数化的控制器来指导搜索过程。 实验设计： 实验在多个图分类和图回归数据集上进行，验证了S2PGNN在不同预训练GNNs上的有效性。实验结果表明，S2PGNN能够一致性地提高预训练GNNs的性能。 对比方法： S2PGNN与传统的微调方法（如Vanilla Fine-Tuning）以及其他领域的先进微调策略（如Feature Extractor、Last-k Tuning和Adapter-Tuning）进行了对比，证明了其在图级任务上的优越性。 未来研究方向： 论文建议未来的研究可以探索如何开发更稳健和可迁移的预训练GNNs，以便更容易地适应各种下游图场景。此外，结合其他先进的正则化方法来进一步提升S2PGNN的性能也是一个潜在的研究方向。 Reducing Resource Usage for Continuous Model Updating and Predictive Query Answering in Graph Streams问题背景： 图流数据（Graph Streams）是一类动态变化的图数据，它们在许多领域如医疗、社交网络、金融等领域有广泛应用。动态图神经网络（DGNN）是处理这类数据的强大工具，但它们在连续预测查询和模型更新时面临着显著的训练时间和内存成本。 研究目标： 论文的主要目标是减少在图流数据上进行连续模型更新所需的计算资源，同时保持预测查询的准确性。 方法论： 在线学习算法： 作者提出了一种随机在线算法，该算法同时学习节点的权重分布，并基于这个分布进行加权在线训练。这种方法可以根据数据和工作负载自适应地选择哪些节点更有利于训练。 图核密度估计（Graph KDE）： 为了平滑权重分布并提高学习质量，作者设计了一种新颖的图KDE技术。这种技术基于随机游走核，考虑了网络拓扑结构，并且是针对离散分布的。 具体实现： 节点级别的训练划分： 论文提出了一种节点级别的增量训练工作划分方案，每个节点都有自己的训练分区。 随机算法： 通过采样节点并执行这些节点的训练分区来学习节点权重分布。算法使用马尔可夫链理论来证明其收敛性。 图KDE采样： 通过随机游走和种子节点集来实现从平滑的节点权重分布中采样。 实验设计： 作者使用三个真实世界的图流数据集（MIMIC-III医疗数据、Bitcoin交易网络和Reddit社区网络）进行实验。实验对比了标准DGNN模型和提出的在线学习算法（带和不带图KDE增强）的性能。实验评估了训练时间、内存消耗和预测准确性。 对比结果： 实验结果表明，与标准DGNN模型相比，提出的在线学习算法在保持相同准确性的同时，训练时间缩短了几个数量级，内存消耗也减少了数倍到20倍。图KDE增强的版本进一步提高了效率。 NewSP: A New Search Process for Continuous Subgraph Matching over Dynamic Graphs这篇论文提出了一个名为 NewSP 的新型搜索过程，旨在解决动态图中连续子图匹配（Continuous Subgraph Matching, CSM）问题中的不必要计算问题。这些问题主要是由于在搜索空间的过早扩展所导致的。NewSP 通过在操作级别推迟不必要的扩展，避免了过早扩展，同时保持了匹配顺序的初始剪枝能力。 问题背景： 在动态图中进行连续子图匹配时，传统的 CSM 框架会过早地扩展搜索空间，导致不必要的计算。这主要是因为这些框架在匹配顺序上严格对齐，导致在没有邻居的查询顶点上进行了不必要的扩展。 NewSP 方法： NewSP 通过以下方式实现： 操作级别的延迟扩展：NewSP 保持所有兼容集计算（CPTs）在原始位置上，并将每个过早的扩展（EXPs）推迟到其必要性出现之前。这避免了过早扩展，同时保留了匹配顺序的剪枝能力。 多重扩展策略：NewSP 允许连续的扩展，这在对应的查询顶点形成独立集时特别有用。这种策略可以显著减少可能出现的指数级增长的冗余计算。 兼容集重用：由于兼容集可能不会立即扩展，这提供了重用缓存兼容集的机会，从而节省了计算资源。 自适应索引过滤策略：该策略与具体的索引设计无关，可以与多重扩展和兼容集重用相结合，进一步提高性能。 实验部分： 作者在多个真实世界的数据集上进行了广泛的实验，包括 Amazon、LiveJournal、LSBench 和 NetFlow。实验结果表明，NewSP 方法比传统算法提高了两到三个数量级。此外，作者还进行了案例研究，将 NewSP 集成到现有的动态和静态图匹配方法中，证明了其优越性。 对比方法： NewSP 与现有的多种状态最先进的方法进行了比较，包括 CaLiG、RapidFlow、GraphFlow、TurboFlux 和 Symbi。在插入和删除效率、空间效率以及索引构建时间等方面，NewSP 都展现出了优越的性能。 LearnSC: An Efficient and Unified Learning-based Framework for Subgraph Counting Problem这篇论文提出了一个名为LearnSC的高效且统一的基于深度学习的框架，用于解决子图计数问题。子图计数问题在许多应用中都非常重要，如社交网络分析、化学反应模拟等，但它是一个众所周知的难题，因为其核心子程序——子图匹配——是NP完全的。 问题背景： 子图计数问题涉及在数据图中为给定的查询图查找匹配的子图数量。这个问题在数据库系统中是一个基础组件，用于估计复杂连接的成本效益查询计划，同时也有助于通过不同大小和标签的查询图集来理解数据图。 提出方法——LearnSC： LearnSC框架通过五个阶段来解决子图计数问题：分解、表示、交互、估计和聚合。这个框架的关键优势在于它是一个通用解决方案，与现有的基于学习的方法正交，并且它配备了一系列优化措施来显著提高估计结果的准确性。 具体实现： 分解阶段：LearnSC从数据图中提取子结构，并将查询分解为子图。 表示阶段：将数据子结构和查询子图中的节点嵌入到特征向量中。 交互阶段：通过考虑匹配信息，使查询图和数据图之间的节点表示对齐。 估计阶段：将对齐的节点表示输入到深度学习模型中，以估计子图的数量。 聚合阶段：将子查询和子结构的估计结果聚合，得出原始查询图的最终计数。 实验部分： 实验在7个真实世界的数据集上进行，包括社交网络、化学反应和知识图谱等。实验结果表明，LearnSC在准确性、鲁棒性和可扩展性方面都优于现有的基于统计和基于学习的竞争方法。 对比方法： LearnSC与四种基于学习的方法和五种基于统计的方法进行了比较。这些方法包括NSIC、LSS、NeurSC、DMPNN以及Alley、Wander Join、Correlated Sampling、Join Sampling with Upper Bounds和Characteristic Sets等。 未来研究方向： 论文最后提出，未来的研究可以开发新的技术来进一步提高LearnSC每个阶段的估计质量，例如在交互阶段区分节点标签和节点拓扑的影响。这表明LearnSC框架是通用的，可以容纳新的技术来进一步提升性能。 Large Subgraph Matching: A Comprehensive and Efficient Approach for Heterogeneous Graphs这篇论文提出了一种名为CSCE（Clustered Compressed Sparse Rows和Sequential Candidate Equivalence）的综合且高效的方法，用于在异构图上进行大子图匹配。子图匹配问题是图分析中的一个重要任务，涉及在图G中识别给定模式P的所有实例。现有的方法在处理大规模、多样化的图类型和子图匹配任务时往往效率不高。为了解决这个问题，CSCE方法能够为不同的问题设置生成高效的计划。 提出的问题： 如何在异构图中有效地匹配大型模式，尤其是在处理大规模和多样化的图类型时。 采用的方法： **Clustered Compressed Sparse Rows (CCSR)**：这是一种新颖的数据结构，用于存储和索引异构图中的边。通过将数据图中的边进行聚类，并存储为CCSR，可以有效地检索候选匹配。 **Sequential Candidate Equivalence (SCE)**：这是一个用于减少冗余计算的概念，通过识别模式顶点之间的条件独立性，来重用候选集，避免重复匹配。 具体实现： CSCE首先对数据图G进行聚类，将同构的边分组到同一个簇中，并构建CCSR索引。 对于给定的子图匹配任务，CSCE选择性地检索聚类并优化匹配计划，通过Greatest-Constraint-First (GCF)启发式算法快速剪枝候选集，并利用SCE来识别和重用候选集。 CSCE还提出了LargestDescendant-Size-First (LDSF)启发式算法来进一步优化匹配计划，以最大化候选集的重用。 实验部分： 作者在多个真实世界的大型数据图上进行了广泛的实验，包括蛋白质相互作用网络、引文网络、社交网络等。 实验结果表明，CSCE在处理大规模图时比现有技术快两个数量级。 论文还对比了CSCE与现有方法在不同子图匹配变体（边诱导、顶点诱导和同构）上的性能。 对比方法： 作者选择了支持不同子图匹配变体和图类型的最新算法作为基线进行比较，包括GraphPi、GraphFlow、GuP、RapidMatch、VEQ和VF3等。 通过测量总时间成本和峰值内存消耗来评估性能，并设置了时间限制和内存限制来确保实验的可比性。 未来研究方向： 论文提出了未来可能的研究方向，包括减少CCSR的开销，以及将CSCE应用于使用不同启发式算法改进匹配顺序的方法。 IVE: Accelerating Enumeration-based Subgraph Matching via Exploring Isolated Vertices这篇论文提出了一种名为IVE（Isolated Vertices Exploration）的新型子图匹配算法，旨在加速基于枚举的子图匹配过程。子图匹配是图数据库中的一项基本任务，它在多个领域如化学信息学、社交网络分析等有着广泛的应用。然而，传统的基于枚举的子图匹配方法在查询图的顶点数量增加时，其性能会呈指数级下降，这是因为其时间复杂度与查询图中的顶点数成指数关系。 问题： IVE算法旨在解决的问题是提高基于枚举的子图匹配算法的性能，尤其是在处理大型查询图时的性能问题。 方法： IVE算法通过在重排序和枚举阶段利用孤立顶点来加速子图匹配过程。孤立顶点是指在查询图中不与其他顶点相连的顶点。算法的核心思想是在重排序阶段通过最大化孤立顶点的数量来减少需要枚举的非孤立顶点的数量，从而降低匹配过程的时间复杂度。 实现： IVE算法包括两个主要阶段： 重排序阶段：开发了一种名为MDE（Maximum Deleted Edges）的重排序算法，目标是最小化非孤立顶点的数量。MDE算法通过迭代选择具有最多边的查询顶点来实现这一点。 枚举阶段：在这个阶段，IVE算法排除了孤立顶点，只枚举非孤立顶点。通过构建一个二分图，IVE算法可以使用二分图匹配算法在多项式时间内计算孤立顶点的匹配。 实验： 实验部分，作者在多个真实世界的数据集上评估了IVE算法的性能，包括不同规模、稀疏性和领域的图。实验结果表明，IVE算法在各种场景下都优于现有的最先进算法，如Sun’s算法、RapidMatch和BICE等。实验使用了两个指标来评估性能：未解决的查询实例数量和总执行时间。 对比： IVE算法与现有算法的对比主要体现在处理复杂查询图的能力上。实验结果表明，IVE算法在所有数据集上的未解决查询实例数量最少，且总执行时间最短。此外，IVE算法在处理不同密度和大小的查询图时都表现出色。 Graph Condensation for Inductive Node Representation Learning这篇论文提出了一种名为映射感知图凝缩（Mapping-aware Graph Condensation，简称 MCond）的方法，旨在解决图神经网络（Graph Neural Networks，简称 GNNs）在处理大规模图数据时面临的显著计算挑战。这些挑战严重限制了 GNNs 在多种应用中的有效性。为了克服这一问题，作者提出了 MCond，它通过显式学习从原始节点到合成节点的一对多节点映射，将新节点无缝集成到合成图中，以实现归纳表示学习。这使得直接在合成图上进行信息传播，比在原始大型图上更高效。 问题背景： GNNs 在处理大规模图时面临计算瓶颈，因为它们通常需要对整个图进行卷积操作，这导致时间和空间消耗与节点数量成二次方和线性关系。现有的图凝缩（Graph Condensation，简称 GC）方法主要集中在训练阶段的效率，而对推理&#x2F;部署阶段，特别是在存在归纳节点时的关注不足。 方法介绍： MCond 通过交替优化方案和从传导和归纳角度创新的损失项，促进了图凝缩和节点映射学习的相互促进。具体来说，MCond 学习一个稀疏的映射矩阵，将每个原始节点视为一些合成节点的加权集合，并通过查找其在完整图中的邻居及其映射到合成节点的对应关系，为归纳节点与合成图之间建立加权边。 实现细节： 标签基于梯度匹配（Learning S）：通过梯度对齐来学习合成图 S，使得在原始图和合成图上训练的 GNN 表现出相似的学习轨迹。 拓扑保持图凝缩（Learning S）：提出了一种新的基于结构的优化目标，以保留原始图中的信息，并将其作为监督信号引入合成图。 传导映射约束（Learning M）：通过传导约束来学习映射矩阵 M，使得每个原始节点可以通过对应的合成节点来表示。 归纳映射约束（Learning M）：通过归纳约束来准备 M，使其能够合理地连接归纳节点和合成图，以便直接从合成图 S 进行信息传播。 实验设计： 作者在三个真实世界的数据集上评估了 MCond，包括一个引用网络（Pubmed）、一个图像网络（Flickr）和一个社交网络（Reddit）。实验设计了两种场景：节点批量（node batch）和图批量（graph batch），以评估 MCond 在不同设置下的性能。此外，还考虑了四种评估设置，包括在原始图和合成图上训练和推理。 对比分析： MCond 与其他图简化方法（如随机选择、度选择、Herding、K-Center 和虚拟节点图）进行了比较。实验结果表明，MCond 在保持高精度的同时，显著提高了推理速度和减少了存储需求。 未来研究方向： 尽管 MCond 能够与图凝缩方法集成，但其性能受到图凝缩结果质量的显著影响。因此，未来的工作方向可以探索增强图凝缩对大规模数据集变化的鲁棒性的策略。 Fast Query Answering by Labeling Index on Uncertain Graphs这篇论文提出了一种基于索引的方法，用于在不确定图（Uncertain Graphs, UGs）上快速回答查询。不确定图是一种图模型，其中每条边的存在都与特定的概率相关联。这种图在社交网络分析、生物信息学等领域有广泛应用。在这些应用中，查询处理是一个基础且关键的任务，但现有的方法（如蒙特卡洛采样和启发式方法）在效率和准确性之间存在显著的权衡，或者缺乏对不同图和查询的泛化能力。 提出的问题： 如何在不确定图上高效且准确地回答查询，包括可靠性查询（两个节点是否连接）、期望可靠距离查询（所有连接路径的加权平均长度）和距离约束的可靠性查询（两个节点在d跳内连接的概率）。 采用的方法： 论文提出了一种新颖的基于索引的方法，称为UR-index，通过预计算和存储操作符来构建标签索引框架，从而加速查询回答过程。 具体实现： 通过构建一个标签索引框架，将耗时的采样过程转化为离线索引操作计算，使得查询回答只需要遍历有限数量的操作符，从而显著加快响应时间。 利用顶点覆盖及其h-hop扩展来剪枝索引结构，减少空间复杂度。 论文还提出了VecUR-index和HoVecUR-index，基于顶点覆盖和h-hop顶点覆盖的索引结构，以进一步优化效率和准确性之间的权衡。 实验部分： 论文在五个真实世界的数据集上进行了实验，包括LastFM、NetHEPT、Epinions、Notre Dame和Google。 实验结果表明，所提出的索引框架在效率上优于现有的不确定图查询方法，并且随着图规模的增长，改进效果更加明显。 对比方法： 论文将提出的索引方法与现有的三种基于启发式采样的方法进行了对比，包括Lazy Propagation Sampling (LPS)、Basic Stratified Sampling (BSS)和Recursive Stratified Sampling (RSS)。 通过比较平均查询时间、相对误差、绝对误差和均方误差等指标，展示了索引方法在查询效率和准确性上的优势。 未来研究方向： 尽管索引方法提供了高效率的查询，但构建索引的计算成本仍然很高，因此需要设计更有效的剪枝技术。 考虑到大型动态不确定图，即图拓扑变化时，索引应如何调整，是另一个有趣的研究方向。 论文还提到了在资源充足的情况下，可以通过增加索引构建时的样本大小来提高准确性。 Fair Top-k Query on Alpha-Fairness这篇论文提出了一种名为α-fairness的公平性模型，旨在解决传统top-k查询中可能存在的歧视问题，尤其是在涉及少数群体（如女性和少数族裔）的决策场景中。论文的主要贡献和内容可以总结如下： 提出了什么： α-fairness模型：一个量化top-k结果集公平性的新模型。 FairTQ-Exact算法：一个精确的框架，用于找到具有最小修改惩罚的公平效用函数。 FairTQ-Exact-BnB算法：一个基于分支定界法的快速算法，用于提高FairTQ-Exact的效率。 为了解决什么问题： 传统的top-k查询可能因为设计不当的效用函数而导致对某些群体的歧视。α-fairness模型旨在量化效用函数的公平性，并找到既公平又接近用户原始偏好的效用函数。 采用了什么方法来实现： 设计了α-fairness模型来量化效用函数的公平性。 提出了FairTQ-Exact算法，通过枚举所有可能的top-k集合并计算它们的α-fairness，找到具有最大α-fairness的效用函数。 提出了FairTQ-Exact-BnB算法，利用α-fairness的上界来剪枝搜索空间，减少需要处理的top-k集合数量。 具体怎么实现的： FairTQ-Exact算法通过超平面方法枚举所有可行的top-k集合，计算它们的α-fairness，并使用二次规划找到具有最小修改惩罚的效用函数。 FairTQ-Exact-BnB算法在FairTQ-Exact的基础上，通过计算less-than和greater-than区域的α-fairness上界，使用分支定界法来减少需要枚举的区域。 实验怎么做的： 在合成数据集和真实数据集上进行了广泛的实验，包括XING、COMPAS、DOT等。 评估了算法的有效性（α-fairness）和效率（响应时间）。 分析了不同参数（如α、p、k、数据集大小）对算法性能的影响。 怎么对比的： 与现有的公平性排名算法（如SR-Adapt、Greedy、Prop、FA*IR）进行了比较。 展示了在不同数据集规模和维度下，提出的算法与其他基线算法在响应时间和公平性上的性能差异。 未来的研究方向： 将公平性问题扩展到其他场景，例如考虑元组之间的相对排名。 探索其他公平性度量方法，如KL散度的变体，以处理未知的受保护群体。 论文还提到了实验结果证明了所提出算法的有效性和效率，并在真实和合成数据集上展示了这些算法的性能。 Efficient Set-based Order Dependency Discovery with a Level-wise Hybrid Strategy这篇论文提出了一种高效的基于集合的顺序依赖（Order Dependencies, ODs）发现方法，称为HyOD，以及其多线程并行版本HyOD+。这些方法旨在解决数据库查询优化中的排序操作问题，通过自动从数据中发现隐藏的顺序依赖关系。顺序依赖关系描述了属性之间的排序规范，对于优化数据库查询中的排序操作非常有效。 问题背景： 在数据库查询中，经常需要根据某些属性的顺序来排序数据。这些顺序依赖关系（ODs）可以用于查询优化，以减少查询执行所需的时间和资源。然而，手动设计这些依赖关系既昂贵又不可行，因此需要自动化的方法来发现这些依赖关系。 方法介绍： HyOD方法采用了一种新颖的层次混合策略，结合了样本数据上的依赖发现和整个实例上的依赖验证。这个过程是逐层进行的，直到在样本上的发现结果收敛到整个实例上的结果。HyOD方法还引入了动态样本大小的概念，可以在不影响发现结果的正确性和完整性的情况下，根据需要增量地细化样本。此外，HyOD方法还通过多线程并行处理来提高效率。 具体实现： HyOD方法的核心是层次混合策略，它在不同层次上交替进行样本数据上的OD发现和整个数据集上的OD验证。这种方法可以确保在样本上发现的ODs在整体数据集上也是有效的。HyOD方法还包括了一些优化技术，例如在验证过程中选择违反OD的元组对来细化样本，以及多线程并行处理来加速OD验证过程。 实验设计： 作者使用了一系列真实和合成的数据集来评估HyOD方法。实验结果与现有的最先进方法FastOD进行了比较，包括运行时间、可扩展性和内存效率。实验还研究了不同的参数设置，如初始样本大小和用于细化样本的违反元组对的数量。 对比结果： 实验结果表明，HyOD方法在所有测试的数据集上都显著优于FastOD，运行时间快达两个数量级。HyOD+通过多线程并行处理进一步提高了效率，平均加速比为2.7倍，最高可达4.5倍。此外，HyOD方法在内存使用上也更为高效，FastOD在某些数据集上因内存不足而失败。 未来研究方向： 论文最后提出了未来的研究方向，包括将HyOD方法与用户交互结合起来，以满足不同用户应用的需求。例如，可以开发工具来帮助用户从发现的ODs中选择有意义或相关的依赖关系，以用于查询优化、数据清洗或完整性维护等任务。此外，作者还计划探索HyOD方法在其他类型的数据依赖发现任务中的应用 Efficient Multi-query Oriented Continuous Subgraph Matching论文主要关注于动态图中的多查询连续子图匹配（MQCSM）问题，这是一个在诸如信用卡欺诈检测、网络攻击追踪和谣言检测等领域具有广泛应用的重要任务。现有的连续子图匹配（CSM）算法主要针对单一查询进行设计，但在实际应用中，往往需要同时处理多个查询，这就要求算法能够高效地处理多查询的情况。 提出的问题：论文指出，尽管已有一些MQCSM的解决方案，但它们由于性能不佳而变得过时。因此，作者提出了一个新的问题：如何在动态图中高效地处理面向多个查询的连续子图匹配问题。 采用的方法：为了解决这个问题，作者提出了一个名为MQ-Match的新方法。MQ-Match包括两个主要部分： 候选分类图（CCG）：这是一个紧凑而有效的索引结构，用于维护数据图中顶点的局部匹配结果。 增量匹配算法：该算法基于查询图的深度优先搜索树构建一组匹配树，并通过利用CCG来收集查询图的增量匹配，确保查询图中的公共结构只被匹配一次。 具体实现： CCG的构建：CCG是一个有向图，其顶点与数据图相同，有向边表示一个顶点至少出现在一个查询图的部分匹配中。CCG的构建包括确定数据图中顶点的状态，这涉及到构建邻域匹配图（NMG）和设置顶点状态。 匹配树的构建：匹配树是基于查询图的深度优先搜索树构建的，每个匹配树对应于查询图中的一个唯一匹配边。匹配树的构建采用了一种贪婪算法，选择未访问顶点中具有最多匹配顶点的标签来扩展匹配树。 基于CCG的匹配树搜索：当数据图发生更新时，算法会找到与更新边对应的匹配树，并在这个匹配树上执行回溯搜索，以收集所有增量匹配。 实验部分：作者在六个真实数据集上进行了广泛的实验，包括Facebook、Slashdot、Wikipedia、Netflow、Youtube和Twitch。实验评估了MQ-Match在离线阶段（索引构建时间和内存使用）和在线阶段（查询时间，包括索引更新和增量匹配搜索时间）的性能。实验结果表明，MQ-Match在大多数设置下比现有解决方案更快，消耗的内存更少。 对比部分：MQ-Match与多个现有算法进行了对比，包括IncMQO、TRIC+、CaLiG、RapidFlow、Symbi和Graphflow。对比结果显示，MQ-Match在索引构建时间和在线查询处理方面都优于这些算法。 Efficient Learning-based Top-k Representative Similar Subtrajectory Query论文主要研究了在大量轨迹数据集中，如何高效地查询与给定查询轨迹最相似的前k个代表性子轨迹（subtrajectories）的问题。 提出的问题： 随着位置技术的发展和轨迹数据的增加，轨迹数据挖掘成为时空数据分析领域的焦点。与以往研究集中在整个轨迹的相似性不同，本文关注在大量轨迹集合中的子轨迹相似性，并提出了一个名为Top-k Representative Similar Subtrajectory Query（TRSSQ）的问题。目的是在大型轨迹数据集中识别与查询轨迹最相似的前k个子轨迹。 解决的问题： 在大规模轨迹数据库中，直接检索相似子轨迹可能会引入冗余，且计算成本高。本文旨在解决如何在保证结果多样性的同时，高效地检索出最具代表性的相似子轨迹。 采用的方法： 为了解决这一挑战，作者提出了一个基于学习的框架，并利用了一个深度学习模型，称为Representative Similarity Score Estimation（RSSE），来高效地近似子轨迹相似度得分，并显著减少候选集。 具体实现： RSSE模型：该模型能够估计数据轨迹与查询轨迹之间所有可能子轨迹的最高相似度得分，而无需计算数据轨迹中每个单独子轨迹的相似度得分。 过滤和验证范式：使用RSSE预测查询轨迹与数据库中所有轨迹之间的代表性相似度得分。在验证阶段，通过计算候选轨迹中代表性相似子轨迹的相似度得分来得出最终的前k个结果。 实验部分： 作者在多个真实世界的数据集上进行了实验评估，包括西安、成都和波尔图的出租车轨迹数据集。实验从两个方面进行评估：1) RSSE和其他基于学习的模型在准确预测前k个代表性相似度得分方面的性能；2) 通过学习基础过滤器和其他过滤方法获得的前k个代表性相似子轨迹的质量。 对比部分： 实验中，作者将RSSE模型与其他几种基线方法进行了比较，包括SRN、T3S和TMN等。此外，还比较了不同的过滤方法，如OSF、Grid Filter和LBF（Learning-Based Filter）。通过一系列的实验，作者证明了RSSE在预测代表性相似度得分方面的有效性和效率，并展示了所提出方法在大规模数据环境中的潜在应用性。 Efficient Example-Guided Interactive Graph Search这篇论文研究了交互式图搜索（Interactive Graph Search, IGS）问题。在这个问题中，给定一个查询实体φ，目标是在有向无环图（DAG）概念层次结构H中找到最能描述φ的目标概念，通过与一个oracle（即知识源）的交互来实现。每次交互都是以“φ是否属于概念u？”的形式提问，oracle的回答只能是YES或NO。IGS算法的效率是通过识别目标概念所需提问的数量，即查询成本来衡量的。 提出的问题： 如何在DAG概念层次结构中高效地识别查询实体的目标概念。 采用的方法： 论文提出了两种算法：Target-Sensitive IGS (TS-IGS) 和 Example-Guided IGS (EG-IGS)。 具体实现： TS-IGS算法：这是一个理论上的改进算法，它在DFS heavy-path tree上运行，通过结果敏感的二分搜索（result-sensitive binary search）来找到最深的YES-concept，从而提高了搜索效率。TS-IGS的查询成本复杂度为O(log n · log L &#x2F; log n + d · logd n)，其中L是从树根到目标概念的路径长度。 EG-IGS算法：这是一个实际应用中的算法，它利用了实体的知识，通过类似φ的示例引导提问。EG-IGS算法的工作流程包括： 收集与φ类似的示例集E。 从E中导出有希望的问题（或概念）集Q。 识别Q中最深的YES-concept t。 在t根的子树上调用TS-IGS算法来识别目标概念。 实验： 论文在六个真实世界的数据集上进行了广泛的实验，包括图像、文本和基因序列。 实验结果显示EG-IGS在查询成本上优于所有现有竞争对手，最多提高了两个数量级。 为了进一步展示EG-IGS技术的真正可行性，作者还开发了一个全自动的亚马逊产品分类演示系统，使用GPT-3.5作为oracle。 对比： 论文将提出的算法与现有的几种算法进行了比较，包括IGS、BinG、STBIS和MIGS。 通过对比平均查询成本，展示了EG-IGS在不同数据集上的性能优势。 未来研究方向： 论文提出了几个未来研究方向，包括处理多目标问题、探索更强大的oracle定义以及研究独立噪声oracle设置，其中oracle对每个问题的答复正确的概率为某个大于1&#x2F;2的常数p。 总的来说，这篇论文在理论和实践上都对IGS问题进行了深入研究，并提出了一种新的高效算法EG-IGS，通过实验验证了其在不同数据集上的有效性。同时，论文还探讨了如何将这种技术应用于实际的自动化分类系统，并指出了未来研究的可能方向。 CSM-TopK: Continuous Subgraph Matching with TopK Density Constraints这篇论文提出了一个名为CSM-TopK的新型问题，即在动态加权图中持续计算给定查询图的k个最高密度的子图匹配。这个问题是为了解决在动态图中进行子图匹配时，现有方法返回的匹配结果数量可能非常庞大，给分析人员带来压力，并且没有考虑到加权图的情况。在许多现实世界的应用中，如支付网络，图中的边权重代表了交易金额，因此匹配的子图可能具有不同的分析优先级。 为了解决的问题： 现有连续子图匹配（CSM）方法返回的匹配结果数量可能过多，难以处理。 现有方法没有考虑加权图，忽略了图中边的权重信息。 在加权图上，需要一种机制来帮助分析人员快速识别高优先级的匹配子图。 采用的方法： 论文提出了一种新的CSM-TopK问题，通过定义星形子查询（star-structured subquery），设计了两种轻量级索引：全局MWstar和局部MWstar。 引入了基于查询的图压缩技术，以提高时间和空间性能。 具体实现方式： 定义了星形子查询和基于此的全局MWstar索引，维护每个特定星形子查询的所有部分匹配的最大权重。 设计了局部MWstar索引，基于对应数据顶点的最大权重分布。 提出了一种基于查询的图压缩技术，以减少搜索起点的数量，特别是在发生删除操作时。 实验部分： 在真实世界的数据集上进行了广泛的实验，包括Amazon、LiveJournal、Human和YouTube数据集。 实验评估了插入和删除操作的效率，以及不同k值和查询大小对性能的影响。 比较了不同方法在空间效率和索引构建时间上的表现。 对比方法： 与现有的静态子图匹配方法（KiSD和PBSM）以及连续子图匹配方法（GraphFlow、RapidFlow和CaLiG）进行了比较。 实验结果显示，论文提出的方法在更新时间和空间效率上都优于比较的方法。 未来研究方向： 论文提到CSM-TopK可能会返回重叠的匹配结果，因此未来的工作可能会集中在如何在CSM-TopK的框架下返回多样化的匹配结果。 可能会探索更高效的索引结构和搜索策略，以进一步优化CSM-TopK的计算性能。 A Critical Re-evaluation of Benchmark Datasets for (Deep) Learning-Based Matching Algorithms论文主要关注实体解析（Entity Resolution, ER）领域中的基准数据集的质量，特别是这些数据集在评估基于（深度）学习的匹配算法时的适用性。 提出的问题： 实体解析是识别一个或多个数据库中指向同一实体的记录的过程。尽管已有多种技术被开发出来解决ER挑战，但现有文献中尚未对用于基于学习匹配算法实验评估的基准数据集的质量进行检验。论文指出，大多数流行的基准数据集过于简单，不适合评估基于学习匹配算法的性能。 采用的方法： 为了填补这一空白，作者提出了四种不同的方法来评估13个已建立的数据集的难度和适用性： 理论上的方法，包括新的线性度量和现有的复杂度度量。 实践上的方法，包括最佳非线性匹配器与线性匹配器之间的差异，以及最佳基于学习匹配器与完美预言者之间的差异。 具体实现： 提出了新的理论度量方法，如线性度量，以及将现有的复杂度度量首次应用于ER基准。 实现了一种新的方法，通过创建四个新的匹配任务来生成基准数据集，并验证这些新基准更具挑战性，因此更适合该领域的进一步发展。 通过开源的非线性机器学习（ML）和深度学习（DL）匹配算法来评估这些度量，并与新提出的线性分类器进行比较，以估计非线性基于学习匹配算法的优势。 实验方法： 对13个流行的ER基准数据集进行了系统评估，实验表明这些数据集大多过于简单，无法适当评估复杂匹配器（如基于DL的匹配器）的预期改进。 提出了一种新的创建ER基准数据集的方法，并通过实验证明了这些新基准数据集更适合评估基于DL匹配器的优势。 对比方法： 通过比较新旧基准数据集的难度和适用性，展示了新方法的有效性。 使用了多种度量方法，包括理论上的线性度量和复杂度度量，以及实践上的非线性提升（NLB）和基于学习的差距（LBM）。 未来研究方向： 论文提出，未来的研究可以探索不同的DeepBlocker配置或不同的阻断方法，以从简单的数据集中提取出具有挑战性的基准数据集。 作者计划创建一系列涵盖整个基准难度范围的数据集，以促进ER领域的进一步发展。 总的来说，这篇论文对现有的ER基准数据集进行了批判性重新评估，并提出了一种新的方法来生成更适合评估基于深度学习的匹配算法的基准数据集。通过理论和实践的结合，作者为ER领域的研究提供了新的视角和工具。","tags":["论文"]},{"title":"最优化理论与方法","path":"/2024/10/16/最优化理论与方法/","content":"绪论最优化问题概述最优化的数学模型一般形式标准形式最优化问题分类经典优化问题(静态优化问题)根据数学模型中有无约束函数分为有约束的最优化问题和无约束的最优化问题;根 据目标函数和约束函数的函数类型分类:线性最优化问题(整数规划、0－1规划)、非线性最优化问题、二次规划、多目标规划。 现代优化问题（动态优化问题动态规划与最优控制问题组合优化问题 对偶问题对偶转换规则：符号填写规则大化小：约束让变量反号，变量让约束同号小化大：变量让约束反号，约束让变量同号","categories":["课程"]},{"title":"Discovering Association Rules from Big Graphs","path":"/2024/10/14/Discovering-Association-Rules-from-Big-Graphs/","content":"阅读方法： 首先，看摘要，了解这几篇论文解决了什么问题； 然后，看例子（examples），更加直观的理解所要解决的问题； 接着，看定义，理解问题的形式化（严谨）定义； 最后，试着理解算法，以及实验的大致内容 面临问题发现图规则的两个挑战： 返回过多规则 无法很好地扩展到大规模图上 解决方法采取了三种策略来解决问题： Application-driven rule discovery（应用驱动策略）：通过机器学习模型，削减那些与用户兴趣无关的规则和数据。 Sampling big graphs（采样大图）：由于经应用驱动策略削减后的数据仍然可能很大，所以还需采样。需要考虑采样率，召回率和支持度。 Parallel scalability（并行扩展）：保证可以使用并行的方法，确保能够在大图上使用。","categories":["论文阅读"]},{"title":"1750.删除字符串两端相同字符后的最短长度","path":"/2024/10/10/1750-删除字符串两端相同字符后的最短长度/","content":"题目给你一个只包含字符 &#39;a&#39;，&#39;b&#39; 和 &#39;c&#39; 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次： 选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。 选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。 前缀和后缀在字符串中任意位置都不能有交集。 前缀和后缀包含的所有字符都要相同。 同时删除前缀和后缀。 请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。 示例 1： 123输入：s = &quot;ca&quot;输出：2解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。 示例 2： 1234567输入：s = &quot;cabaabac&quot;输出：0解释：最优操作序列为：- 选择前缀 &quot;c&quot; 和后缀 &quot;c&quot; 并删除它们，得到 s = &quot;abaaba&quot; 。- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;baab&quot; 。- 选择前缀 &quot;b&quot; 和后缀 &quot;b&quot; 并删除它们，得到 s = &quot;aa&quot; 。- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;&quot; 。 示例 3： 12345输入：s = &quot;aabccabba&quot;输出：3解释：最优操作序列为：- 选择前缀 &quot;aa&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;bccabb&quot; 。- 选择前缀 &quot;b&quot; 和后缀 &quot;bb&quot; 并删除它们，得到 s = &quot;cca&quot; 。 提示： 1 &lt;= s.length &lt;= 105 s 只包含字符 &#39;a&#39;，&#39;b&#39; 和 &#39;c&#39; 。 题解12345678910111213141516171819class Solution &#123; public int minimumLength(String s) &#123; char[] ss = s.toCharArray(); int n = s.length(); int count = n; char p; int left,right; for(left=0,right=n-1;left&lt;right&amp;&amp;ss[left]==ss[right];)&#123; p=ss[left]; while(left&lt;=right&amp;&amp;p==ss[left])&#123;// 注意这里要把边界判断放前面，防止数组访问越界（如：&quot;bbbbbbbbbbbbbbbbbbb&quot;）。 left++; &#125; while(left&lt;=right&amp;&amp;p==ss[right])&#123; right--; &#125; &#125; return right-left+1; &#125;&#125; 知识点注意边界判断，防止越界。","tags":["算法"],"categories":["LeetCode","单序列双指针_相向双指针"]},{"title":"系统环境小命令","path":"/2024/10/09/系统环境小命令/","content":"Pytorch版本1conda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia","tags":["环境"],"categories":["积累"]},{"title":"209.长度最小的子数组","path":"/2024/10/08/209-长度最小的子数组/","content":"题目给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 题解12345678910111213141516class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int sum=0; int n=nums.length; int ans=n+1; for(int right=0, left=0;right&lt;n;right++)&#123; sum+=nums[right]; while(sum&gt;=target)&#123; ans = Math.min(ans,right-left+1); sum-=nums[left]; left++; &#125; &#125; return ans &lt;= n ? ans : 0; &#125;&#125; 知识点注意考虑何时更新结果，以及返回值的判定（子数组就是它本身，以及找不到这样的子数组）。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最短/最小"]},{"title":"Windows文件夹快捷图标变为英文一键修复","path":"/2024/09/27/Windows文件夹快捷图标变为英文一键修复/","content":"起因由于Win11抽风，OneDrive自动同步，导致今天打开电脑，桌面上出现了很多以前账号的旧文件，同时导致Windows桌面文件夹路径发生改变，变成在OneDrive文件夹下。 解决将OneDrive卸载后，将文件夹移除到原位置或删除。发现桌面文件夹名字在路径中不会自动变成英文。于是在网上寻找解决方案，发现了文件夹修复脚本，可以将文件夹路径改成英文且显示中文，还能创建误删的文件夹。（修复过后需要将原来的文件夹的内容手动移到新文件夹中。） .bat程序代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144@echo offtitle 常见特殊文件夹修复工具cd /d “%~dp0”:beginclsecho ****************************************echo.echo 请选择要修复的特殊文件夹echo.echo [1] 桌面 [2] 图片 [3] 视频echo [4] 文档 [5] 下载 [6] 音乐echo [7] 3D 对象 [8] Roaming [0] 退出echo.echo _________________________________________echo.set /p num=请输入你的选择（0-8）：if &quot;%num%&quot;==&quot;1&quot; goto zmif &quot;%num%&quot;==&quot;2&quot; goto tpif &quot;%num%&quot;==&quot;3&quot; goto spif &quot;%num%&quot;==&quot;4&quot; goto wdif &quot;%num%&quot;==&quot;5&quot; goto xzif &quot;%num%&quot;==&quot;6&quot; goto yyif &quot;%num%&quot;==&quot;7&quot; goto 3dif &quot;%num%&quot;==&quot;8&quot; goto rmif &quot;%num%&quot;==&quot;0&quot; goto tcgoto begin:zmset folder=&quot;桌面&quot;set ini=&quot;desktop&quot;set name=&quot;Desktop&quot;set value=&quot;%USERPROFILE%\\Desktop&quot;set valueex=&quot;%%USERPROFILE%%\\Desktop&quot;set clsid=&quot;&#123;754AC886-DF64-4CBA-86B5-F7FBF4FBCEF5&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:tpset folder=&quot;图片&quot;set ini=&quot;Pictures&quot;set name=&quot;My Pictures&quot;set value=&quot;%USERPROFILE%\\Pictures&quot;set valueex=&quot;%%USERPROFILE%%\\Pictures&quot;set clsid=&quot;&#123;0DDD015D-B06C-45D5-8C4C-F59713854639&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:spset folder=&quot;视频&quot;set ini=&quot;Videos&quot;set name=&quot;My Video&quot;set value=&quot;%USERPROFILE%\\Videos&quot;set valueex=&quot;%%USERPROFILE%%\\Videos&quot;set clsid=&quot;&#123;35286A68-3C57-41A1-BBB1-0EAE73D76C95&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:wdset folder=&quot;文档&quot;set ini=&quot;Documents&quot;set name=&quot;Personal&quot;set value=&quot;%USERPROFILE%\\Documents&quot;set valueex=&quot;%%USERPROFILE%%\\Documents&quot;set clsid=&quot;&#123;F42EE2D3-909F-4907-8871-4C22FC0BF756&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:xzset folder=&quot;下载&quot;set ini=&quot;Downloads&quot;set name=&quot;&#123;374DE290-123F-4565-9164-39C4925E467B&#125;&quot;set value=&quot;%USERPROFILE%\\Downloads&quot;set valueex=&quot;%%USERPROFILE%%\\Downloads&quot;set clsid=&quot;&#123;7d83ee9b-2244-4e70-b1f5-5393042af1e4&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:yyset folder=&quot;音乐&quot;set ini=&quot;Music&quot;set name=&quot;My Music&quot;set value=&quot;%USERPROFILE%\\Music&quot;set valueex=&quot;%%USERPROFILE%%\\Music&quot;set clsid=&quot;&#123;A0C69A99-21C8-4671-8703-7934162FCF1D&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:3dset folder=&quot;3D 对象&quot;set ini=&quot;3D Objects&quot;set name=&quot;&#123;31C0DD25-9439-4F12-BF41-7FF4EDA38722&#125;&quot;set value=&quot;%USERPROFILE%\\3D Objects&quot;set valueex=&quot;%%USERPROFILE%%\\3D Objects&quot;set clsid=&quot;&quot;call :fixsubecho.&amp;pause&amp;goto begin:rmset folder=&quot;Roaming&quot;set ini=&quot;&quot;set name=&quot;AppData&quot;set value=&quot;%USERPROFILE%\\AppData\\Roaming&quot;set valueex=&quot;%%USERPROFILE%%\\AppData\\Roaming&quot;set clsid=&quot;&quot;reg add &quot;HKEY_CURRENT_USER\\Volatile Environment&quot; /v %name% /t reg_sz /d %value% /fcall :fixsubecho.&amp;pause&amp;goto begin:tcexit:fixsubecho.echo 修复%folder%文件夹echo.echo 结束桌面进程...taskkill /f /im explorer.exeecho.echo 创建文件夹%value%...mkdir %value%echo.if %ini% neq &quot;&quot; (echo 修复desktop.ini文件...attrib -s -h -r -a %value%\\desktop.iniecho y | xcopy %ini%\\desktop.ini %value%\\ /-Y /A /Hattrib +s +h +a %value%\\desktop.iniattrib +r %value%echo.)echo 修复Shell Folders下%name%的路径...reg add &quot;HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders&quot; /v %name% /t reg_sz /d %value% /fecho.echo 修复User Shell Folders下%name%的路径...reg add &quot;HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders&quot; /v %name% /t reg_expand_sz /d %valueex% /fecho.if %clsid% neq &quot;&quot; (echo 删除User Shell Folders下的%clsid%...reg delete &quot;HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders&quot; /v %clsid% /f 2&gt;nul)echo.echo 重启桌面进程...start explorer.exeecho.goto :eof","tags":["Windows"],"categories":["脚本"]},{"title":"2516.每种字符至少取 K 个","path":"/2024/09/25/2516-每种字符至少取-K-个/","content":"题目给你一个由字符 &#39;a&#39;、&#39;b&#39;、&#39;c&#39; 组成的字符串 s 和一个非负整数 k 。每分钟，你可以选择取走 s 最左侧 还是 最右侧 的那个字符。 你必须取走每种字符 至少 k 个，返回需要的 最少 分钟数；如果无法取到，则返回 -1 。 示例 1： 1234567输入：s = &quot;aabaaaacaabc&quot;, k = 2输出：8解释：从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。共需要 3 + 5 = 8 分钟。可以证明需要的最少分钟数是 8 。 示例 2： 123输入：s = &quot;a&quot;, k = 1输出：-1解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 -1 。 提示： 1 &lt;= s.length &lt;= 105 s 仅由字母 &#39;a&#39;、&#39;b&#39;、&#39;c&#39; 组成 0 &lt;= k &lt;= s.length 题解123456789101112131415161718192021222324252627282930class Solution &#123; public int takeCharacters(String s, int k) &#123; int[] remains = new int[3]; // 每个字符取k个后，应剩余的个数 int[] counts = new int[3]; // 该字符串中每个字符的个数 int n=s.length(); for(int i=0;i&lt;n;i++)&#123; char c = s.charAt(i); counts[c-&#x27;a&#x27;]++; &#125; // 不满足取的条件 for(int i=0;i&lt;3;i++)&#123; remains[i]= counts[i]-k; if(remains[i]&lt;0)&#123; return -1; &#125; &#125; int ans=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c=s.charAt(right); // 该字符在剩余字符串中 remains[c-&#x27;a&#x27;]--; while(remains[c-&#x27;a&#x27;]&lt;0)&#123; char p = s.charAt(left); remains[p-&#x27;a&#x27;]++; left++; &#125; ans = Math.max(ans,right-left+1); &#125; return n-ans; &#125;&#125; 知识点逆向思维 + 滑动窗口 由于每次都是从最左侧 或 最右侧 取字符，剩下的肯定是子字符串，所以可以使用滑动窗口。 需要返回的 最少 分钟数，即剩下的字符串最长，还要保证取走的字符满足个数要求，也就是还需要考虑剩下的字符串中的字符个数要求。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1838.最高频元素的频数","path":"/2024/09/24/1838-最高频元素的频数/","content":"题目元素的 频数 是该元素在一个数组中出现的次数。 给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。 执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。 示例 1： 1234输入：nums = [1,2,4], k = 5输出：3解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。4 是数组中最高频元素，频数是 3 。 示例 2： 123456输入：nums = [1,4,8,13], k = 5输出：2解释：存在多种最优解决方案：- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。 示例 3： 12输入：nums = [3,9,6], k = 2输出：1 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= 105 题解12345678910111213141516171819class Solution &#123; public int maxFrequency(int[] nums, int k) &#123; int n=nums.length; Arrays.sort(nums); int ans=1; long count=0; for(int right=1,left=0;right&lt;n;right++)&#123; count+=(long)(nums[right]-nums[right-1])*(right-left); while(count&gt;k&amp;&amp;left&lt;=right)&#123; count-=nums[right]-nums[left]; left++; &#125; ans=Math.max(ans,right-left+1); &#125; return ans; &#125;&#125; 知识点题目翻译：求一个数组中，如何使用给定的次数k，将数组中某些元素执行k次的加1操作，使得数组中相同元素尽可能地多。结果要的是这个元素的频数。 应当对【离我们选定的最高频元素最近的元素】进行加1操作。这个最近指的是，差值最近。经过排序后，也就是距离最近。 再次翻译题目：如何在有限的k次操作中，尽可能多的让某个区间中的值相等，求这个最长区间的长度。使用滑动窗口。 操作数的计算公式：count += (long)(nums[right] - nums[right - 1]) * (right - left);注意：这里需要强制转换为long，不然会溢出有样例过不了。 图解如下：","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1658.将 x 减到 0 的最小操作数","path":"/2024/09/23/1658-将-x-减到-0-的最小操作数/","content":"题目给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。 示例 1： 123输入：nums = [1,1,4,2,3], x = 5输出：2解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2： 12输入：nums = [5,6,7,8,9], x = 4输出：-1 示例 3： 123输入：nums = [3,2,20,1,1,3], x = 10输出：5解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 1 &lt;= x &lt;= 109 题解123456789101112131415161718192021222324252627class Solution &#123; public int minOperations(int[] nums, int x) &#123; long sum =0; int n = nums.length; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; long target = sum-x; if(target&lt;0)&#123; return -1; &#125; int ans=-1; long sum1 = 0; for(int left=0,right=0;right&lt;n;right++)&#123; sum1+=nums[right]; while(sum1&gt;target)&#123; sum1-=nums[left]; left++; &#125; if(target==sum1)&#123; ans = Math.max(ans,right-left+1); &#125; &#125; return ans==-1?ans:n-ans; &#125;&#125; 知识点思路：逆向思维，滑动窗口 每次都是移除数组 nums 最左边或最右边的元素，剩下的数组肯定是子数组。因此，想到使用滑动窗口。 求的是最小操作数，即剩下的子数组长度最长且子数组和为原数组和减x。 注意需要判断特殊情况：x比原数组和还大。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2779.数组的最大美丽值","path":"/2024/09/20/2779-数组的最大美丽值/","content":"题目给你一个下标从 0 开始的整数数组 nums 和一个 非负 整数 k 。 在一步操作中，你可以执行下述指令： 在范围 [0, nums.length - 1] 中选择一个 此前没有选过 的下标 i 。 将 nums[i] 替换为范围 [nums[i] - k, nums[i] + k] 内的任一整数。 数组的 美丽值 定义为数组中由相等元素组成的最长子序列的长度。 对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。 注意：你 只 能对每个下标执行 一次 此操作。 数组的 子序列 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。 示例 1： 1234567输入：nums = [4,6,1,2], k = 2输出：3解释：在这个示例中，我们执行下述操作：- 选择下标 1 ，将其替换为 4（从范围 [4,8] 中选出），此时 nums = [4,4,1,2] 。- 选择下标 3 ，将其替换为 4（从范围 [0,4] 中选出），此时 nums = [4,4,1,4] 。执行上述操作后，数组的美丽值是 3（子序列由下标 0 、1 、3 对应的元素组成）。可以证明 3 是我们可以得到的由相等元素组成的最长子序列长度。 示例 2： 1234输入：nums = [1,1,1,1], k = 10输出：4解释：在这个示例中，我们无需执行任何操作。数组 nums 的美丽值是 4（整个数组）。 提示： 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i], k &lt;= 105 题解1234567891011121314151617181920class Solution &#123; public int maximumBeauty(int[] nums, int k) &#123; Arrays.sort(nums); int n=nums.length; int count=0; int ans=0; for(int left=0,right=0;right&lt;n;right++)&#123; // System.out.println(nums[right]); count++; while((nums[left]+k &lt; nums[right]-k )&amp;&amp;left&lt;right)&#123; left++; count--; &#125; ans=Math.max(ans,count); &#125; return ans; &#125; &#125; 知识点排序 + 滑动窗口 根据子序列和美丽值的定义可知：最终所求结果和元素顺序无关。因此，可以将原数组排序，得到如下图的区间图： 题目所求的相等元素组成的最长子序列，相当于选出若干闭区间，交集不为空。 经过排序后，区间是连续的，只需考虑最左边区间[left−k,left+k]和最右边区间[right−k,right+k]的交集不为空，即可保证之间的这些区间也不为空，即：left+k &gt;= right-k。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2958.最多 K 个重复元素的最长子数组","path":"/2024/09/20/2958-最多-K-个重复元素的最长子数组/","content":"题目给你一个整数数组 nums 和一个整数 k 。 一个元素 x 在数组中的 频率 指的是它在数组中的出现次数。 如果一个数组中所有元素的频率都 小于等于 k ，那么我们称这个数组是 好 数组。 请你返回 nums 中 最长好 子数组的长度。 子数组 指的是一个数组中一段连续非空的元素序列。 示例 1： 1234输入：nums = [1,2,3,1,2,3,1,2], k = 2输出：6解释：最长好子数组是 [1,2,3,1,2,3] ，值 1 ，2 和 3 在子数组中的频率都没有超过 k = 2 。[2,3,1,2,3,1] 和 [3,1,2,3,1,2] 也是好子数组。最长好子数组的长度为 6 。 示例 2： 1234输入：nums = [1,2,1,2,1,2,1,2], k = 1输出：2解释：最长好子数组是 [1,2] ，值 1 和 2 在子数组中的频率都没有超过 k = 1 。[2,1] 也是好子数组。最长好子数组的长度为 2 。 示例 3： 1234输入：nums = [5,5,5,5,5,5,5], k = 4输出：4解释：最长好子数组是 [5,5,5,5] ，值 5 在子数组中的频率没有超过 k = 4 。最长好子数组的长度为 4 。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 1 &lt;= k &lt;= nums.length 题解12345678910111213141516171819class Solution &#123; public int maxSubarrayLength(int[] nums, int k) &#123; int ans=0; int n=nums.length; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int left=0,right=0;right&lt;n;right++)&#123; map.merge(nums[right],1,Integer::sum); while(map.get(nums[right])&gt;k)&#123; map.merge(nums[left],-1,Integer::sum); if(map.get(nums[left])==0)&#123; map.remove(nums[left]); &#125; left++; &#125; ans=Math.max(ans,right-left+1); &#125; return ans; &#125;&#125; 知识点简单题，只需使用哈希表和滑动窗口。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1695.删除子数组的最大得分","path":"/2024/09/20/1695-删除子数组的最大得分/","content":"题目给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。 返回 只删除一个 子数组可获得的 最大得分 。 如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。 示例 1： 123输入：nums = [4,2,4,5,6]输出：17解释：最优子数组是 [2,4,5,6] 示例 2： 123输入：nums = [5,2,1,2,5,2,1,2,5]输出：8解释：最优子数组是 [5,2,1] 或 [1,2,5] 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 题解12345678910111213141516171819202122class Solution &#123; public int maximumUniqueSubarray(int[] nums) &#123; int n=nums.length; int ans=0; int count=0; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int left=0,right=0;right&lt;n;right++)&#123; map.put(nums[right],map.getOrDefault(nums[right],0)+1); count+=nums[right]; while(map.size()&lt;right-left+1)&#123; map.merge(nums[left],-1,Integer::sum); count-=nums[left]; if(map.get(nums[left])==0)&#123; map.remove(nums[left]); &#125; left++; &#125; ans=Math.max(ans,count); &#125; return ans; &#125;&#125; 知识点主要是怎么判断若干个不同元素的子数组。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"904.水果成篮","path":"/2024/09/19/904-水果成篮/","content":"题目你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length 题解1234567891011121314151617181920212223class Solution &#123; public int totalFruit(int[] fruits) &#123; int ans=0; int n=fruits.length; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int left=0,right=0;right&lt;n;right++)&#123; while(map.size()&gt;2&amp;&amp;left&lt;=right)&#123; map.merge(fruits[left], -1, Integer::sum); if(map.get(fruits[left])==0)&#123; map.remove(fruits[left]); &#125; left++; &#125; map.merge(fruits[right], 1, Integer::sum); if(map.size()&lt;=2)&#123; ans=Math.max(ans,right-left+1); &#125; &#125; return ans; &#125;&#125; 知识点磕绊地方：更新结果时。没加判断会导致多出一个。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2730.找到最长的半重复子字符串","path":"/2024/09/18/2730-找到最长的半重复子字符串/","content":"题目给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。 如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串 t 是 半重复的 。例如，&quot;0010&quot; 、&quot;002020&quot; 、&quot;0123&quot; 、&quot;2002&quot; 和 &quot;54944&quot; 是半重复字符串，而 &quot;00101022&quot; （相邻的相同数字对是 00 和 22）和 &quot;1101234883&quot; （相邻的相同数字对是 11 和 88）不是半重复字符串。 请你返回 s 中最长 半重复 子字符串 的长度。 示例 1： 输入：s &#x3D; “52233” 输出：4 解释： 最长的半重复子字符串是 “5223”。整个字符串 “52233” 有两个相邻的相同数字对 22 和 33，但最多只能选取一个。 示例 2： 输入：s &#x3D; “5494” 输出：4 解释： s 是一个半重复字符串。 示例 3： 输入：s &#x3D; “1111111” 输出：2 解释： 最长的半重复子字符串是 “11”。子字符串 “111” 有两个相邻的相同数字对，但最多允许选取一个。 提示： 1 &lt;= s.length &lt;= 50 &#39;0&#39; &lt;= s[i] &lt;= &#39;9&#39; 题解12345678910111213141516171819202122class Solution &#123; public int longestSemiRepetitiveSubstring(String s) &#123; int ans=1; var s1 = s.toCharArray(); int n=s1.length; int same=0; for(int l=0,r=1;r&lt;n;r++)&#123; if(s1[r]==s1[r-1])&#123; same++; &#125; if(same&gt;1)&#123; l++; while(s1[l]!=s1[l-1])&#123; l++; &#125; same--; &#125; ans = Math.max(ans,r-l+1); &#125; return ans; &#125;&#125; 知识点还是搞不懂怎么滑的问题。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1208.尽可能使字符串相等","path":"/2024/09/17/1208-尽可能使字符串相等/","content":"题目给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例 1： 123输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3输出：3解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。 示例 2： 123输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3输出：1解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。 示例 3： 123输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0输出：1解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。 提示： 1 &lt;= s.length, t.length &lt;= 10^5 0 &lt;= maxCost &lt;= 10^6 s 和 t 都只含小写英文字母。 题解1234567891011121314151617181920212223class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; // 将字符串转换为字符数组 char[] s1 = s.toCharArray(); char[] t1 = t.toCharArray(); int count=0; int n=s.length(); int[] costs = new int[n]; for(int i=0;i&lt;n;i++)&#123; costs[i]=Math.abs(s1[i]-t1[i]); &#125; int cost=0; for(int left=0,right=0;right&lt;n;right++)&#123; cost+=costs[right]; while(cost&gt;maxCost)&#123; cost-=costs[left]; left++; &#125; count=Math.max(count,right-left+1); &#125; return count; &#125;&#125; 知识点看到子字符串，联想到使用滑动窗口。但是滑动窗口需要在同一个存储空间才能滑，结合条件：每个字符串长度相同，且有预算要求。因此，想到在这两个字符串转变的花费数组上进行滑动。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1493.删掉一个元素以后全为 1 的最长子数组","path":"/2024/09/17/1493-删掉一个元素以后全为-1-的最长子数组/","content":"题目给你一个二进制数组 nums ，你需要从中删掉一个元素。 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。 如果不存在这样的子数组，请返回 0 。 提示 1： 123输入：nums = [1,1,0,1]输出：3解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。 示例 2： 123输入：nums = [0,1,1,1,0,1,1,0,1]输出：5解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。 示例 3： 123输入：nums = [1,1,1]输出：2解释：你必须要删除一个元素。 提示： 1 &lt;= nums.length &lt;= 105 nums[i] 要么是 0 要么是 1 。 题解1234567891011121314151617class Solution &#123; public int longestSubarray(int[] nums) &#123; int n=nums.length; int count=0; int ans=0; for(int right=0,left=0;right&lt;n;right++)&#123; count+=1-nums[right]; while(count&gt;1&amp;&amp;left&lt;=right)&#123; count-=1-nums[left]; left++; &#125; ans = Math.max(ans,right-left); &#125; return ans; &#125;&#125; 知识点这题是1004. 最大连续1的个数 III的特例，即k=1。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1004.最大连续1的个数 III","path":"/2024/09/17/1004-最大连续1的个数-III/","content":"题目给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。 示例 1： 1234输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释：[1,1,1,0,0,1,1,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2： 1234输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3输出：10解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示： 1 &lt;= nums.length &lt;= 105 nums[i] 不是 0 就是 1 0 &lt;= k &lt;= nums.length 题解12345678910111213141516class Solution &#123; public int longestOnes(int[] nums, int k) &#123; int n=nums.length; int ans=0; int count=0;// 记录0的个数 for(int left=0,right=0;right&lt;n;right++)&#123; count+=1-nums[right]; while(count&gt;k&amp;&amp;left&lt;=right)&#123; count-=1-nums[left]; left++; &#125; ans = Math.max(ans,right-left+1); &#125; return ans; &#125;&#125; 知识点题意转换：把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为 「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」。 求最大连续子区间，可以使用滑动窗口方法。 滑动窗口的限制条件是：窗口内最多有 K 个 0。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"3090.每个字符最多出现两次的最长子字符串","path":"/2024/09/14/3090-每个字符最多出现两次的最长子字符串/","content":"题目给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该 子字符串 的 最大 长度。 示例 1： 输入： s &#x3D; “bcbbbcba” 输出： 4 解释： 以下子字符串长度为 4，并且每个字符最多出现两次：&quot;bcbbbcba&quot;。 示例 2： 输入： s &#x3D; “aaaa” 输出： 2 解释： 以下子字符串长度为 2，并且每个字符最多出现两次：&quot;aaaa&quot;。 提示： 2 &lt;= s.length &lt;= 100 s 仅由小写英文字母组成。 题解1234567891011121314151617class Solution &#123; public int maximumLengthSubstring(String s) &#123; int n=s.length(); HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int len=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c = s.charAt(right); while(left&lt;right&amp;&amp;map.getOrDefault(c, 0) == 2)&#123; map.put(s.charAt(left),map.get(s.charAt(left))-1); left++; &#125; map.put(c,map.getOrDefault(c, 0)+1); len=Math.max(len,right-left+1); &#125; return len; &#125;&#125; 不太优雅，使用merge 123456789101112131415161718class Solution &#123; public int maximumLengthSubstring(String s) &#123; //滑动窗口 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; int left = 0; for(int right = 0; right &lt; s.length(); right++) &#123; char ch = s.charAt(right); while(map.getOrDefault(ch, 0) &gt;= 2) &#123; map.merge(s.charAt(left), -1, Integer::sum);//left对应字符个数减少1 left++; &#125; map.merge(ch, 1, Integer::sum); res = Math.max(res, right - left + 1); &#125; return res; &#125;&#125; 知识点Map 接口的 merge 方法允许你在给定的键不存在的情况下插入一个新值，或者当键已经存在时应用合并函数。 1V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) 参数 key: 要插入或更新的键。 value: 如果键不存在，则插入的默认值。 remappingFunction: 如果键已存在，则应用的合并函数。这个函数接受两个参数，一个是当前映射的值，另一个是默认值，并返回一个新的值。 Integer::sum 作为合并函数，这是一个引用 Integer 类的静态方法 sum 的方法引用。Integer::sum 接受两个 int 参数并返回它们的和。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"3.无重复字符的最长子串","path":"/2024/09/14/3-无重复字符的最长子串/","content":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题解123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int n=s.length(); int len=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c = s.charAt(right); while(left&lt;right&amp;&amp;set.contains(c))&#123; //存在相同元素 set.remove(s.charAt(left)); left++; &#125; set.add(c); len=Math.max(len,right-left+1); &#125; return len; &#125;&#125; 知识点滑动窗口模板： 12345678//外层循环扩展右边界，内层循环扩展左边界for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;\t//当前考虑的元素\twhile (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意 //扩展左边界 &#125; //区间[left,right]符合题意，统计相关信息&#125; HashSet： 判断是否有重复的字符。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2653.滑动子数组的美丽值","path":"/2024/09/13/2653-滑动子数组的美丽值/","content":"题目给你一个长度为 n 的整数数组 nums ，请你求出每个长度为 k 的子数组的 美丽值 。 一个子数组的 美丽值 定义为：如果子数组中第 x 小整数 是 负数 ，那么美丽值为第 x 小的数，否则美丽值为 0 。 请你返回一个包含 n - k + 1 个整数的数组，依次 表示数组中从第一个下标开始，每个长度为 k 的子数组的 美丽值 。 子数组指的是数组中一段连续 非空 的元素序列。 示例 1： 123456输入：nums = [1,-1,-3,-2,3], k = 3, x = 2输出：[-1,-2,-2]解释：总共有 3 个 k = 3 的子数组。第一个子数组是 [1, -1, -3] ，第二小的数是负数 -1 。第二个子数组是 [-1, -3, -2] ，第二小的数是负数 -2 。第三个子数组是 [-3, -2, 3] ，第二小的数是负数 -2 。 示例 2： 1234567输入：nums = [-1,-2,-3,-4,-5], k = 2, x = 2输出：[-1,-2,-3,-4]解释：总共有 4 个 k = 2 的子数组。[-1, -2] 中第二小的数是负数 -1 。[-2, -3] 中第二小的数是负数 -2 。[-3, -4] 中第二小的数是负数 -3 。[-4, -5] 中第二小的数是负数 -4 。 示例 3： 12345678输入：nums = [-3,1,2,-3,0,-3], k = 2, x = 1输出：[-3,0,-3,-3,-3]解释：总共有 5 个 k = 2 的子数组。[-3, 1] 中最小的数是负数 -3 。[1, 2] 中最小的数不是负数，所以美丽值为 0 。[2, -3] 中最小的数是负数 -3 。[-3, 0] 中最小的数是负数 -3 。[0, -3] 中最小的数是负数 -3 。 提示： n == nums.length 1 &lt;= n &lt;= 105 1 &lt;= k &lt;= n 1 &lt;= x &lt;= k -50 &lt;= nums[i] &lt;= 50 题解123456789101112131415161718192021222324class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n=nums.length; int[] bn = new int[n-k+1]; int[] count = new int[50*2+1]; for(int i=0;i&lt;k-1;i++)&#123; count[nums[i]+50]++;// 由于nums中的数很小，所以采用计数排序。 &#125; int x1; for(int i=k-1;i&lt;n;i++)&#123; count[nums[i]+50]++; x1=x; for(int j=0;j&lt;50;j++)&#123;// 因为看的是负数，所以只需要遍历负数。 x1-=count[j];// 重点在于这里。 if(x1&lt;=0)&#123; bn[i-(k-1)]=j-50; break; &#125; &#125; count[nums[i-(k-1)]+50]--; &#125; return bn; &#125;&#125; 123456789101112131415161718192021222324252627// 自己开始写的超时了。我的思路是将窗口中的数排序，采用的方法是先转换为列表（因为列表直接添加和删除顺序不变），再由列表转为数组，再采用Arrays.sort()进行排序，取第x个数进行判断。// TODO 暂时还没想到改进方法class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n=nums.length; int[] temp = new int[k]; int[] b = new int[n-k+1]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int count=0; for(int i=0;i&lt;n;i++)&#123; list.add(nums[i]); if(i&lt;k-1)&#123; continue; &#125; temp = list.stream().mapToInt(Integer::intValue).toArray(); Arrays.sort(temp); if(temp[x-1]&lt;0)&#123; b[count]=temp[x-1]; &#125;else&#123; b[count]=0; &#125; count++; list.remove(Integer.valueOf(nums[i-(k-1)])); &#125; return b; &#125;&#125; 知识点滑动窗口 + 计数排序。 思路：在于如何理解第x小的数。 假设第x小的数为num，那么小于num的数的个数肯定小于x，大于num的数的个数肯定大于等于x。两个条件结合才能保证num为第x小的数。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"国内镜像源","path":"/2024/09/13/国内镜像源/","content":"pip常用镜像源清华大学 1https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 1https://mirrors.aliyun.com/pypi/simple/ 网易 1https://mirrors.163.com/pypi/simple/ 豆瓣 1https://pypi.mirrors.ustc.edu.cn/simple/ 中科大 1https://pypi.mirrors.ustc.edu.cn/simple/","categories":["积累"]},{"title":"Anaconda环境创建与卸载","path":"/2024/09/13/Anaconda环境创建与卸载/","content":"环境创建1conda create -n XXX python=3.9 环境删除1conda remove -n XXX --all 环境激活1conda activate XXX 环境查看1conda env list","tags":["Anaconda"],"categories":["技巧"]},{"title":"1423.可获得的最大点数","path":"/2024/09/13/1423-可获得的最大点数/","content":"题目几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 123输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 123输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 123输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 123输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 12输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length 题解12345678910111213141516171819202122232425class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int sum=0; int all=0; int min=Integer.MAX_VALUE; int n=cardPoints.length; int m=n-k;// 新窗口 for(int i=0;i&lt;n;i++) &#123; all += cardPoints[i]; &#125; if(m==0)&#123; return all; &#125;else&#123; for(int i=0;i&lt;n;i++)&#123; sum+=cardPoints[i]; if(i&lt;m-1)&#123; continue; &#125; min = Math.min(min,sum); sum-=cardPoints[i-(m-1)]; &#125; return all-min; &#125; &#125;&#125; 知识点思路：逆向思维。 首先，将问题判断为定长滑动窗口问题：虽然，每次拿牌都可以从开头或者末尾拿一张，总共要拿k张牌。但是，所剩余的牌必定是n-k张（n为牌的总数），且剩余的牌必定是连续的。 然后，要使得拿走的牌点数和最大，那么就意味着剩下的连续牌点数最小。 最后，问题变成求n-k长的子数组和的最小值。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"Hexo博客文档间跳转","path":"/2024/09/12/Hexo博客文档间跳转/","content":"Makdown语法同一目录下，可以这么写： 1[hello-world.Md](hello-world.md) 示例：hello-world.Md Hexo标签使用post_link标签&#123;% post_link 文件名 %&#125;或者&#123;% post_link 文件名 自定义标题 %&#125; 12&#123;% post_link hello-world %&#125;&#123;% post_link hello-world 你好世界 %&#125; 示例：Hello World 你好世界","tags":["Hexo"],"categories":["技巧"]},{"title":"2461.长度为 K 子数组中的最大和","path":"/2024/09/12/2461-长度为-K-子数组中的最大和/","content":"题目给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和： 子数组的长度是 k，且 子数组中的所有元素 各不相同 。 返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。 子数组 是数组中一段连续非空的元素序列。 示例 1： 123456789输入：nums = [1,5,4,2,9,9,9], k = 3输出：15解释：nums 中长度为 3 的子数组是：- [1,5,4] 满足全部条件，和为 10 。- [5,4,2] 满足全部条件，和为 11 。- [4,2,9] 满足全部条件，和为 15 。- [2,9,9] 不满足全部条件，因为元素 9 出现重复。- [9,9,9] 不满足全部条件，因为元素 9 出现重复。因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。 示例 2： 12345输入：nums = [4,4,4], k = 3输出：0解释：nums 中长度为 3 的子数组是：- [4,4,4] 不满足全部条件，因为元素 4 出现重复。因为不存在满足全部条件的子数组，所以返回 0 。 提示： 1 &lt;= k &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 题解1234567891011121314151617181920212223242526272829class Solution &#123; public long maximumSubarraySum(int[] nums, int k) &#123; int n=nums.length; long sum=0; long max=0; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); &#125;else&#123; map.put(nums[i],1); &#125; if(i&lt;k-1)&#123; continue; &#125; if(sum&gt;max &amp;&amp; map.size()==k)&#123; max=sum; &#125; sum-=nums[i-(k-1)]; if(map.get(nums[i-(k-1)])==1)&#123; map.remove(nums[i-(k-1)]); &#125;else&#123; map.put(nums[i-(k-1)],map.get(nums[i-(k-1)])-1); &#125; &#125; return max; &#125;&#125; 知识点和2841.几乎唯一子数组的最大和这篇文章基本一样，只是在更新时，判断有所不一样。 Hello World 你好世界","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2841.几乎唯一子数组的最大和","path":"/2024/09/12/2841-几乎唯一子数组的最大和/","content":"题目给你一个整数数组 nums 和两个正整数 m 和 k 。 请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。 如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。 子数组指的是一个数组中一段连续 非空 的元素序列。 示例 1： 123输入：nums = [2,6,7,3,1,7], m = 3, k = 4输出：18解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。 示例 2： 123输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3输出：23解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。 示例 3： 123输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3输出：0解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。 提示： 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= m &lt;= k &lt;= nums.length 1 &lt;= nums[i] &lt;= 109 题解12345678910111213141516171819202122232425262728293031class Solution &#123; public long maxSum(List&lt;Integer&gt; nums, int m, int k) &#123; HashMap&lt;Integer ,Integer&gt; map = new HashMap&lt;&gt;(); int n=nums.size(); long max=0; long sum=0; // 注意要使用long型，否则越界 for(int i=0;i&lt;n;i++)&#123; sum+=nums.get(i); if(map.containsKey(nums.get(i)))&#123; map.put(nums.get(i),map.get(nums.get(i))+1); &#125;else&#123; map.put(nums.get(i),1); &#125; if(i&lt;k-1)&#123; continue; &#125; // System.out.printlni&quot;map&quot;+map.size()); if(sum&gt;max&amp;&amp;map.size()&gt;=m)&#123; max=sum; &#125; sum-=nums.get(i-(k-1)); if(map.get(nums.get(i-(k-1)))==1)&#123; map.remove(nums.get(i-(k-1))); &#125;else&#123; map.put(nums.get(i-(k-1)),map.get(nums.get(i-(k-1)))-1); &#125; //map.remove(i-(k-1)); &#125; return max; &#125;&#125; 知识点思路：求子数组的 最大和是常规定长滑动窗口问题，这题对我来说难点在于如何判断唯一，我想到使用哈希表，它能保证键唯一。哈希表的键为该位置i的原数组的值，哈希表的值为该值在一个滑动窗口中出现的次数。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1052.爱生气的书店老板","path":"/2024/09/12/1052-爱生气的书店老板/","content":"题目有一个书店老板，他的书店开了 n 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 n 的整数数组 customers ，其中 customers[i] 是在第 i 分钟开始时进入商店的顾客数量，所有这些顾客在第 i 分钟结束后离开。 在某些分钟内，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 minutes 分钟不生气，但却只能使用一次。 请你返回 这一天营业下来，最多有多少客户能够感到满意 。 示例 1： 1234输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 示例 2： 12输入：customers = [1], grumpy = [0], minutes = 1输出：1 提示： n == customers.length == grumpy.length 1 &lt;= minutes &lt;= n &lt;= 2 * 104 0 &lt;= customers[i] &lt;= 1000 grumpy[i] == 0 or 1 题解1234567891011121314151617181920212223242526class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int minutes) &#123; int n=customers.length; int sum=0;// 记录老板不生气时的顾客数量 for(int i=0;i&lt;n;i++)&#123; if(grumpy[i]==0)&#123; sum+=customers[i]; &#125; &#125; int m = 0;// 记录3分钟内老板生气，离开的顾客数量最大值 int ns=0; for(int i=0;i&lt;n;i++)&#123; if(grumpy[i]==1)&#123; ns+=customers[i]; &#125; if(i&lt;minutes-1)&#123; continue; &#125; m = Math.max(m,ns); if(grumpy[i-(minutes-1)]==1)&#123; ns-=customers[i-(minutes-1)]; &#125; &#125; return m+sum; &#125;&#125; 知识点思路：分情况讨论。 所求的是最多有多少客户能够感到满意，包括：1.本来就满意的顾客数量（即，老板不生气时间内的顾客总数）+2.使用密码技巧minutes分钟内，使得本来因老板生气而被赶走的顾客数量。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1652.拆炸弹","path":"/2024/09/11/1652-拆炸弹/","content":"题目你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例 1： 123输入：code = [5,7,1,4], k = 3输出：[12,10,16,13]解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 示例 2： 123输入：code = [1,2,3,4], k = 0输出：[0,0,0,0]解释：当 k 为 0 时，所有数字都被 0 替换。 示例 3： 123输入：code = [2,4,9,3], k = -2输出：[12,5,6,13]解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。 提示： n == code.length 1 &lt;= n &lt;= 100 1 &lt;= code[i] &lt;= 100 -(n - 1) &lt;= k &lt;= n - 1 题解1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[] decrypt(int[] code, int k) &#123; int n=code.length; int[] m = new int[n]; Arrays.fill(m,0); if(k==0)&#123; return m; &#125; int j=0; int sum=0; int count=0;// 记录窗口的数量 if(k&gt;0)&#123; // 窗口位置[1，k]; for(int i=1;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125;else&#123; // 窗口位置[n-k, n-k+k) k=-k; for(int i=n-k;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125; &#125;&#125; 优化：寻找规律，可以发现当k大于0和k小于0时，只有窗口的起始位置不一样。因此，两类可以合并 1234567891011121314151617181920212223242526class Solution &#123; public int[] decrypt(int[] code, int k) &#123; int n=code.length; int[] m = new int[n]; Arrays.fill(m,0); if(k==0)&#123; return m; &#125; int j=0; int sum=0; int count=0; int r = k&gt;0 ? 1 : n+k; k = Math.abs(k); for(int i=r;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125;&#125; 知识点滑动窗口问题，主要考虑窗口大小以及窗口的起始位置。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2379.得到 K 个黑块的最少涂色次数","path":"/2024/09/11/2379-得到-K-个黑块的最少涂色次数/","content":"题目给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 &#39;W&#39; 要么是 &#39;B&#39; ，表示第 i 块的颜色。字符 &#39;W&#39; 和 &#39;B&#39; 分别表示白色和黑色。 给你一个整数 k ，表示想要 连续 黑色块的数目。 每一次操作中，你可以选择一个白色块将它 涂成 黑色块。 请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。 示例 1： 1234567输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7输出：3解释：一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。得到 blocks = &quot;BBBBBBBWBW&quot; 。可以证明无法用少于 3 次操作得到 7 个连续的黑块。所以我们返回 3 。 示例 2： 12345输入：blocks = &quot;WBWBBBW&quot;, k = 2输出：0解释：不需要任何操作，因为已经有 2 个连续的黑块。所以我们返回 0 。 提示： n == blocks.length 1 &lt;= n &lt;= 100 blocks[i] 要么是 &#39;W&#39; ，要么是 &#39;B&#39; 。 1 &lt;= k &lt;= n 题解12345678910111213141516171819202122class Solution &#123; public int minimumRecolors(String blocks, int k) &#123; int n=0; int min= Integer.MAX_VALUE; char[] block = blocks.toCharArray();; for(int i=0;i&lt;block.length;i++)&#123; if(block[i]==&#x27;W&#x27;)&#123; n++; &#125; if(i&lt;k-1)&#123; continue; &#125; if(n&lt;min)&#123; min=n; &#125; if(block[i-(k-1)]==&#x27;W&#x27;)&#123; n--; &#125; &#125; return min; &#125;&#125; 知识点常规滑动窗口","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2090.半径为 k 的子数组平均值","path":"/2024/09/11/2090-半径为-k-的子数组平均值/","content":"题目给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。 半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。 构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。 x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。 例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。 示例 1： 123456789输入：nums = [7,4,3,9,1,8,5,2,6], k = 3输出：[-1,-1,-1,5,4,4,-1,-1,-1]解释：- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。 示例 2： 12345输入：nums = [100000], k = 0输出：[100000]解释：- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。 示例 3： 1234输入：nums = [8], k = 100000输出：[-1]解释：- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。 提示： n == nums.length 1 &lt;= n &lt;= 105 0 &lt;= nums[i], k &lt;= 105 题解12345678910111213141516171819202122232425class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length; int[] avgs = new int[n]; Arrays.fill(avgs,-1); if(n==1&amp;&amp;k==0)&#123; return nums; &#125; if(2*k&gt;=n)&#123; return avgs; &#125; long sum=0;// 防止超限 int j=k; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(i&lt;2*k)&#123; continue; &#125; avgs[j]=(int)(sum/(2*k+1)); j++; sum-=nums[i-(2*k)]; &#125; return avgs; &#125;&#125; 知识点常规定长滑动窗口问题，注意加上坐标中心，同时注意使用long型，否则会超限。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1343.大小为 K 且平均值大于等于阈值的子数组数目","path":"/2024/09/11/1343-大小为-K-且平均值大于等于阈值的子数组数目/","content":"题目给你一个整数数组 arr 和两个整数 k 和 threshold 。 请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。 示例 1： 123输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4输出：3解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。 示例 2： 123输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5输出：6解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。 提示： 1 &lt;= arr.length &lt;= 105 1 &lt;= arr[i] &lt;= 104 1 &lt;= k &lt;= arr.length 0 &lt;= threshold &lt;= 104 题解123456789101112131415161718class Solution &#123; public int numOfSubarrays(int[] arr, int k, int threshold) &#123; int num=0; double sum=0.0; for(int i=0;i&lt;arr.length;i++)&#123; sum+=arr[i]; if(i&lt;k-1)&#123; continue; &#125; if(sum/k&gt;=threshold)&#123; num++; &#125; sum-=arr[i-(k-1)]; &#125; return num; &#125;&#125; 知识点常规滑动窗口问题，无难点。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"643.子数组最大平均数 I","path":"/2024/09/11/643-子数组最大平均数-I/","content":"题目给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。 示例 1： 123输入：nums = [1,12,-5,-6,50,3], k = 4输出：12.75解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 示例 2： 12输入：nums = [5], k = 1输出：5.00000 提示： n == nums.length 1 &lt;= k &lt;= n &lt;= 105 -104 &lt;= nums[i] &lt;= 104 题解1234567891011121314151617181920212223class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; // if(nums.length==1)&#123; // return nums[0]; // &#125; double avg = 0.0; double max=Integer.MIN_VALUE; int sum=0; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; if(i&lt;k-1)&#123; continue; &#125; avg = 1.0*sum/k; if(avg&gt;max)&#123; max = avg; &#125; sum-=nums[i-(k-1)]; &#125; return max; &#125;&#125; 知识点常规的滑动窗口问题，注意考虑特殊情况：最大值的初始化设置 整型最大值：Integer.MAX_VALUE 整型最小值：Integer.MIN_VALUE","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1456.定长子串中元音的最大数目","path":"/2024/09/10/1456-定长子串中元音的最大数目/","content":"题目给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例 1： 123输入：s = &quot;abciiidef&quot;, k = 3输出：3解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。 示例 2： 123输入：s = &quot;aeiou&quot;, k = 2输出：2解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 123输入：s = &quot;leetcode&quot;, k = 3输出：2解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。 示例 4： 123输入：s = &quot;rhythms&quot;, k = 4输出：0解释：字符串 s 中不含任何元音字母。 示例 5： 12输入：s = &quot;tryhard&quot;, k = 4输出：1 提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length 题解123456789101112131415161718192021222324252627class Solution &#123; public int maxVowels(String S, int k) &#123; char[] s = S.toCharArray(); int max=0; int v=0; for(int i=0;i&lt;s.length;i++)&#123; // 进入窗口 if(s[i]==&#x27;a&#x27;||s[i] == &#x27;e&#x27; || s[i] == &#x27;i&#x27; || s[i] == &#x27;o&#x27; || s[i] == &#x27;u&#x27;)&#123; v++; &#125; // 未到窗口大小 if(i&lt;k-1)&#123; continue; &#125; // 更新 if(v&gt;max)&#123; max=v; &#125; // 出 char out = s[i-(k-1)]; if (out == &#x27;a&#x27; || out == &#x27;e&#x27; || out == &#x27;i&#x27; || out == &#x27;o&#x27; || out == &#x27;u&#x27;) &#123; v--; &#125; &#125; return max; &#125;&#125; 知识点三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果 i &lt; k−1 则重复第一步。更新：更新答案。一般是更新最大值&#x2F;最小值。出：下标为 i − (k-1) 的元素离开窗口，更新相关统计量。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2552.统计上升四元组（题解都看不懂，害）","path":"/2024/09/10/2552-统计上升四元组/","content":"题目给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。 如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的： 0 &lt;= i &lt; j &lt; k &lt; l &lt; n 且 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。 示例 1： 123456输入：nums = [1,3,2,4,5]输出：2解释：- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。没有其他的四元组，所以我们返回 2 。 示例 2： 123输入：nums = [1,2,3,4]输出：0解释：只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。 提示： 4 &lt;= nums.length &lt;= 4000 1 &lt;= nums[i] &lt;= nums.length nums 中所有数字 互不相同 ，nums 是一个排列。 代码知识点"},{"title":"bat批处理脚本自动部署Hexo博客","path":"/2024/09/10/bat批处理脚本自动部署Hexo博客/","content":"原因每次提交博客，都需要进行hexo clean hexo g hexo d指令，十分繁琐 优点Windows中的.bat文件可以直接点击运行，同时还能把多条指令写进一个.bat文件。 代码1234@echo offD:cd D:\\bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo d 指令说明@echo off，关闭回显。D:，切换到博客站点目录所在的盘符cd D:\\blog，进入站点目录hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，清理缓存和部署目录，生成最新的静态文件，部署新生成的静态文件。","tags":["Hexo","自动部署"],"categories":["脚本"]},{"title":"49.字母异位词分组","path":"/2024/09/10/49-字母异位词分组/","content":"题目给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 示例 1: 12输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 示例 2: 12输入: strs = [&quot;&quot;]输出: [[&quot;&quot;]] 示例 3: 12输入: strs = [&quot;a&quot;]输出: [[&quot;a&quot;]] 提示： 1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i] 仅包含小写字母 题解思路：字母异位词的两个字符串的字母相同，仅是顺序不一样。因此，通过排序得到的字符串肯定一样。可以通过哈希表来存储，其中键为排序后的字符串，值为该组异位字符词。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); List&lt;String&gt; list; for (String str : strs) &#123;// 遍历 char[] array = str.toCharArray();// 字符串转字符数组 Arrays.sort(array);// 对字符数组排序 String key = new String(array); if(map.containsKey(key)==true)&#123; list = map.get(key); &#125;else&#123; list = new ArrayList&lt;String&gt;(); &#125; //List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());// map中存在该key，则使用该key对应的value，否则为空List list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 知识点HashMap方法 定义：Map&lt;String ,String&gt; map = new HashMap&lt;String ,String&gt;(); 添加键值对：put(Object key, Object value); 获取映射值：getOrDefault(Object key, V defaultValue); 是否有指定key的映射：boolean containsKey(Object key); String 类方法 字符串转换成字符数组：str.toCharArray(); Arrays类方法 对数组进行排序：Arrays.sort();","tags":["HashMap"],"categories":["LeetCode"]},{"title":"这是文章标题","path":"/2024/08/16/20240114/","content":"文章正文"},{"title":"Hello World","path":"/2024/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418:root&#123; --code-autor: &#x27;© 钟意博客🌙&#x27;; --code-tip: &quot;优雅借鉴&quot;;&#125; /*语法高亮*/ .hljs &#123; position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) &#125; .hljs::before &#123; content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 &#125; .highlight:hover .hljs::before &#123; color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; &#125; .hljs-ln &#123; display: inline-block; overflow-x: auto; padding-bottom: 5px &#125; .hljs-ln td &#123; padding: 0; background-color: var(--block) &#125; .hljs-ln::-webkit-scrollbar &#123; height: 10px; border-radius: 5px; background: #333; &#125; .hljs-ln::-webkit-scrollbar-thumb &#123; background-color: #bbb; border-radius: 5px; &#125; .hljs-ln::-webkit-scrollbar-thumb:hover &#123; background: #ddd; &#125; .hljs table tbody tr &#123; border: none &#125; .hljs .hljs-ln-line &#123; padding: 1px 10px; border: none &#125; td.hljs-ln-line.hljs-ln-numbers &#123; border-right: 1px solid #666; &#125; .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name &#123; color: #c78300 &#125; .hljs-link &#123; color: #569cd6; text-decoration: underline &#125; .hljs-built_in, .hljs-type &#123; color: #4ec9b0 &#125; .hljs-number, .hljs-class &#123; color: #2094f3 &#125; .hljs-string, .hljs-meta-string &#123; color: #4caf50 &#125; .hljs-regexp, .hljs-template-tag &#123; color: #9a5334 &#125; .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula &#123; color: #c78300 &#125; .hljs-property &#123; color: #9c67a1; &#125; .hljs-comment, .hljs-quote &#123; color: #57a64a; font-style: italic &#125; .hljs-doctag &#123; color: #608b4e &#125; .hljs-meta, .hljs-meta-keyword, .hljs-tag &#123; color: #9b9b9b &#125; .hljs-variable, .hljs-template-variable &#123; color: #bd63c5 &#125; .hljs-attr, .hljs-attribute, .hljs-builtin-name &#123; color: #d34141 &#125; .hljs-section &#123; color: gold &#125; .hljs-emphasis &#123; font-style: italic &#125; .hljs-strong &#123; font-weight: bold &#125; .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo &#123; color: #c78300 &#125; .hljs-addition &#123; background-color: #144212; display: inline-block; width: 100% &#125; .hljs-deletion &#123; background-color: #600; display: inline-block; width: 100% &#125; .hljs.language-html::before, .hljs.language-xml::before &#123; content: &quot;HTML/XML&quot; &#125; .hljs.language-javascript::before &#123; content: &quot;JavaScript&quot; &#125; .hljs.language-c::before &#123; content: &quot;C&quot; &#125; .hljs.language-cpp::before &#123; content: &quot;C++&quot; &#125; .hljs.language-java::before &#123; content: &quot;Java&quot; &#125; .hljs.language-asp::before &#123; content: &quot;ASP&quot; &#125; .hljs.language-actionscript::before &#123; content: &quot;ActionScript/Flash/Flex&quot; &#125; .hljs.language-bash::before &#123; content: &quot;Bash&quot; &#125; .hljs.language-css::before &#123; content: &quot;CSS&quot; &#125; .hljs.language-asp::before &#123; content: &quot;ASP&quot; &#125; .hljs.language-cs::before, .hljs.language-csharp::before &#123; content: &quot;C#&quot; &#125; .hljs.language-d::before &#123; content: &quot;D&quot; &#125; .hljs.language-golang::before, .hljs.language-go::before &#123; content: &quot;Go&quot; &#125; .hljs.language-json::before &#123; content: &quot;JSON&quot; &#125; .hljs.language-lua::before &#123; content: &quot;Lua&quot; &#125; .hljs.language-less::before &#123; content: &quot;LESS&quot; &#125; .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before &#123; content: &quot;Markdown&quot; &#125; .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before &#123; content: &quot;Objective-C&quot; &#125; .hljs.language-php::before &#123; content: &quot;PHP&quot; &#125; .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before &#123; content: &quot;Perl&quot; &#125; .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before &#123; content: &quot;Python&quot; &#125; .hljs.language-r::before &#123; content: &quot;R&quot; &#125; .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before &#123; content: &quot;Ruby&quot; &#125; .hljs.language-sql::before &#123; content: &quot;SQL&quot; &#125; .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before &#123; content: &quot;Shell&quot; &#125; .hljs.language-swift::before &#123; content: &quot;Swift&quot; &#125; .hljs.language-vb::before &#123; content: &quot;VB/VBScript&quot; &#125; .hljs.language-yaml::before &#123; content: &quot;YAML&quot; &#125; /*stellar主题补偿*/ .md-text pre&gt;.hljs &#123; padding-top: 2rem !important; &#125; .md-text pre &#123; padding: 0 !important; &#125; code &#123; background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; background-size: 20px 20px !important; background-position: 50% !important; &#125; figure::after &#123; content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 &#125; figcaption span &#123; border-radius: 0px 0px 12px 12px !important; &#125; /* 复制代码按钮 */ .highlight &#123; position: relative; &#125; .highlight .code .copy-btn &#123; position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; &#125; .highlight .code .copy-btn:hover &#123; color: var(--text-code); opacity: 0.75; &#125; .highlight .code .copy-btn.success &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; /* 描述 */ .md-text .highlight figcaption span &#123; font-size: small; &#125; /* 折叠 */ code.hljs &#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; /*-webkit-line-clamp: 6;*/ padding: 1rem 1rem 0 1rem; /* chino建议 */ &#125; .hljsOpen &#123; -webkit-line-clamp: 99999 !important; &#125; .CodeCloseDiv &#123; color: #999; background: var(--block); display: flex; justify-content: center; margin-top: inherit; margin-bottom: -18px; &#125; .CodeClose &#123; color: #999; margin-top: 3px; background: var(--block); &#125; .highlight button:hover, .highlight table:hover+button &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; More info: Deployment"},{"path":"/notes/index.html","content":"zh吱吱吱吱"},{"path":"/more/index.html","content":"我的订阅我的歌单关于本站关于博主 .md-text .tag-plugin.timeline .timenode>.body, .md-text .tag-plugin.timeline .timenode>.header { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }"},{"title":"测试2","path":"/notes/test2.html","content":"测试2 2222222222"},{"path":"/share/index.html","content":"2024 2024-03-09还没有呢"},{"title":"测试","path":"/notes/test.html","content":"测试 11111111111111"},{"path":"/more/about/index.html","content":"我的订阅我的歌单关于本站关于博主 这里是安知命的个人站点。我在这里记录生活的点滴与感悟，也在这里分享和技术相关的内容。希望我的内容对您有所帮助，如果您有任何想法或问题，欢迎在评论区留言。 站点信息 本站使用 Hexo 框架和 Stellar 主题创建，代码托管于 GitHub，站点部署于 Vercel。 评论系统使用 Twikoo 创建，系统部署于 Vercel。 隐私声明 本站非常重视您的隐私及数据安全，在访问本站时，不会收集和存储您的任何数据。 在使用本站评论系统时，会收集和存储您的相关信息，详见 Waline 隐私声明。 本站仅会使用您的信息来提供评论服务，并且尽最大努力保护您的隐私及数据安全。 版权声明 本站所有内容均采用 署名-非商业性使用-禁止演绎 4.0 国际 许可协议，未经授权请勿转载。 本站所有内容均由本人亲自撰写，没有使用任何人工智能生成技术。 免责声明 本站所有内容不代表任何组织的立场和意见，也不构成任何形式的建议或指导。 本站对内容的真实性、完整性、准确性和及时性不作任何保证，也不承担任何法律责任。"},{"path":"/js/services/txmap.js","content":"//get请求 $.ajax({ type: 'get', url: 'https://apis.map.qq.com/ws/location/v1/ip', data: { key: 'XRWBZ-J436B-NOKU3-JPDTY-AWCIH-SXF7X', output: 'jsonp', }, dataType: 'jsonp', success: function (res) { ipLoacation = res; } }) function getDistance(e1, n1, e2, n2) { const R = 6371 const { sin, cos, asin, PI, hypot } = Math let getPoint = (e, n) => { e *= PI / 180 n *= PI / 180 return { x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) } } let a = getPoint(e1, n1) let b = getPoint(e2, n2) let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z) let r = asin(c / 2) * 2 * R return Math.round(r); } function showWelcome() { console.log(ipLoacation) let dist = getDistance(107.754444, 31.148725, ipLoacation.result.location.lng, ipLoacation.result.location.lat); //这里换成自己的经纬度 let pos = ipLoacation.result.ad_info.nation; let ip; let posdesc; //根据国家、省份、城市信息自定义欢迎语 switch (ipLoacation.result.ad_info.nation) { case \"日本\": posdesc = \"よろしく，一起去看樱花吗\"; break; case \"美国\": posdesc = \"Let us live in peace!\"; break; case \"英国\": posdesc = \"想同你一起夜乘伦敦眼\"; break; case \"俄罗斯\": posdesc = \"干了这瓶伏特加！\"; break; case \"法国\": posdesc = \"C'est La Vie\"; break; case \"德国\": posdesc = \"Die Zeit verging im Fluge.\"; break; case \"澳大利亚\": posdesc = \"一起去大堡礁吧！\"; break; case \"加拿大\": posdesc = \"拾起一片枫叶赠予你\"; break; case \"中国\": pos = ipLoacation.result.ad_info.province + \" \" + ipLoacation.result.ad_info.city + \" \" + ipLoacation.result.ad_info.district; ip = ipLoacation.result.ip; switch (ipLoacation.result.ad_info.province) { case \"北京市\": posdesc = \"北——京——欢迎你~~~\"; break; case \"天津市\": posdesc = \"讲段相声吧。\"; break; case \"河北省\": posdesc = \"山势巍巍成壁垒，天下雄关。铁马金戈由此向，无限江山。\"; break; case \"山西省\": posdesc = \"展开坐具长三尺，已占山河五百余。\"; break; case \"内蒙古自治区\": posdesc = \"天苍苍，野茫茫，风吹草低见牛羊。\"; break; case \"辽宁省\": posdesc = \"我想吃烤鸡架！\"; break; case \"吉林省\": posdesc = \"状元阁就是东北烧烤之王。\"; break; case \"黑龙江省\": posdesc = \"很喜欢哈尔滨大剧院。\"; break; case \"上海市\": posdesc = \"众所周知，中国只有两个城市。\"; break; case \"江苏省\": switch (ipLoacation.result.ad_info.city) { case \"南京市\": posdesc = \"这是我挺想去的城市啦。\"; break; case \"苏州市\": posdesc = \"上有天堂，下有苏杭。\"; break; default: posdesc = \"散装是必须要散装的。\"; break; } break; case \"浙江省\": posdesc = \"东风渐绿西湖柳，雁已还人未南归。\"; break; case \"河南省\": switch (ipLoacation.result.ad_info.city) { case \"郑州市\": posdesc = \"豫州之域，天地之中。\"; break; case \"南阳市\": posdesc = \"臣本布衣，躬耕于南阳。此南阳非彼南阳！\"; break; case \"驻马店市\": posdesc = \"峰峰有奇石，石石挟仙气。嵖岈山的花很美哦！\"; break; case \"开封市\": posdesc = \"刚正不阿包青天。\"; break; case \"洛阳市\": posdesc = \"洛阳牡丹甲天下。\"; break; default: posdesc = \"可否带我品尝河南烩面啦？\"; break; } break; case \"安徽省\": posdesc = \"蚌埠住了，芜湖起飞。\"; break; case \"福建省\": posdesc = \"井邑白云间，岩城远带山。\"; break; case \"江西省\": posdesc = \"落霞与孤鹜齐飞，秋水共长天一色。\"; break; case \"山东省\": posdesc = \"遥望齐州九点烟，一泓海水杯中泻。\"; break; case \"湖北省\": posdesc = \"来碗热干面！\"; break; case \"湖南省\": posdesc = \"74751，长沙斯塔克。\"; break; case \"广东省\": posdesc = \"老板来两斤福建人。\"; break; case \"广西壮族自治区\": posdesc = \"桂林山水甲天下。\"; break; case \"海南省\": posdesc = \"朝观日出逐白浪，夕看云起收霞光。\"; break; case \"四川省\": posdesc = \"康康川妹子。\"; break; case \"贵州省\": posdesc = \"茅台，学生，再塞200。\"; break; case \"云南省\": posdesc = \"玉龙飞舞云缠绕，万仞冰川直耸天。\"; break; case \"西藏自治区\": posdesc = \"躺在茫茫草原上，仰望蓝天。\"; break; case \"陕西省\": posdesc = \"来份臊子面加馍。\"; break; case \"甘肃省\": posdesc = \"羌笛何须怨杨柳，春风不度玉门关。\"; break; case \"青海省\": posdesc = \"牛肉干和老酸奶都好好吃。\"; break; case \"宁夏回族自治区\": posdesc = \"大漠孤烟直，长河落日圆。\"; break; case \"新疆维吾尔自治区\": posdesc = \"驼铃古道丝绸路，胡马犹闻唐汉风。\"; break; case \"台湾省\": posdesc = \"我在这头，大陆在那头。\"; break; case \"香港特别行政区\": posdesc = \"永定贼有残留地鬼嚎，迎击光非岁玉。\"; break; case \"澳门特别行政区\": posdesc = \"性感荷官，在线发牌。\"; break; default: posdesc = \"带我去你的城市逛逛吧！\"; break; } break; default: posdesc = \"带我去你的国家逛逛吧。\"; break; } //根据本地时间切换欢迎语 let timeChange; let date = new Date(); if (date.getHours() >= 5 && date.getHours() < 11) timeChange = \"上午好，一日之计在于晨！\"; else if (date.getHours() >= 11 && date.getHours() < 13) timeChange = \"中午好，该摸鱼吃午饭了。\"; else if (date.getHours() >= 13 && date.getHours() < 15) timeChange = \"下午好，懒懒地睡个午觉吧！\"; else if (date.getHours() >= 15 && date.getHours() < 16) timeChange = \"三点几啦，一起饮茶呀！\"; else if (date.getHours() >= 16 && date.getHours() < 19) timeChange = \"夕阳无限好！\"; else if (date.getHours() >= 19 && date.getHours() < 24) timeChange = \"晚上好，夜生活嗨起来！\"; else timeChange = \"夜深了，早点休息，少熬夜。\"; try { //自定义文本和需要放的位置 document.getElementById(\"welcome-info\").innerHTML = `欢迎来自 ${pos} 的小伙伴，${timeChange}您现在距离站长约 ${dist} 公里， ${posdesc} `; } catch (err) { // console.log(\"Pjax无法获取#welcome-info元素🙄🙄🙄\") } } window.onload = showWelcome; // 如果使用了pjax在加上下面这行代码 document.addEventListener('pjax:complete', showWelcome);"},{"path":"/more/music/index.html","content":"我的订阅我的歌单关于本站关于博主"},{"path":"/more/me/index.html","content":"我的订阅我的歌单关于本站关于博主 我的职业目前是一名研究生。 人格类型 测试结果来自 16Personalities。 我的游戏 联系方式 Emailmailto:3101526745@qq.com"},{"title":"这是分页标题","path":"/wiki/hexo-stellar/index.html","content":"z是stellar"},{"title":"测试","path":"/wiki/hexo-stellar/test.html","content":"帆帆帆帆帆帆帆帆。为什么没有啊"}]