[{"title":"论文写作","path":"/2024/10/22/论文写作/","content":"论文写作工具只建议使用Latex，虽然需要写代码，但是容易上手。重要的是格式调整非常方便。本科写毕业论文，经常调整一个地方的格式，导致所有格式都乱了。 而且，每个期刊都会提供格式文件，格式修改非常方便。而且，网上有许多模板文件，通常只需要将对应位置替换为自己论文内容，稍作修改，就能得到一篇新的文章。 学术论文基本概念学术论文是对研究工作的阶段性总结，创新点只需要一两个就足够发表，不需要华丽的文采，但要将正确的内容放在正确的位置，需要有清晰的结构：引言、文献综述、研究方法、实验结果、讨论和结论等部分。 论文并不是想怎么写就怎么写的，需要按照模板写。模板是通过阅读文献（建议读顶刊（打磨得更好），顶会），自己总结而来的；也可以使用别人总结的模板（自己实验室相关方向）。 Latex格式不用重头写，最好是找已经被该期刊录用的论文的源文件，或者是找该期刊提供的模板文件。 cls文件：用于控制论文的总体格式 bst文件：用于控制参考文献的格式 尽量避免使用\\usepackage导入包，以免不兼容，导致期刊投稿网站上无法运行。 慎用的单词与词语一般而言，未在任何学术论文中出现的单词，严禁使用。 可以使用https://search.linggle.com/，来查询单词和词汇的使用频率，一般选择使用频率高的的词。作为初学者，尤其要注意是否滥用某词，所以需要全篇自查。 论文属于正式文章，所以通常不使用缩写，即应使用have not, do not, cannot等。仅当使用authors&#39;之类的情况，才使用撇号。 禁止在句子开头使用And（相邻句子本身就具有相关性，使用And毫无意义），句中慎用and（因为从语义上可能无法并列）； 禁用Easy（简单的东西就没研究价值）； 慎用Simple（与easy类似。可以使用simple yet effective）； 慎用Solve（彻底解决某个难题, 写出了相应的定理与证明，才能使用solve。一般使用handle或address）； 慎用Novel（视工作创新性而定，一般的话使用new，投顶刊顶会使用novel）； Only靠后使用（consider only uniform distribution 而不是 only consider uniform distribution，表达自己有某个能力，而没有做）； 慎用Prove（实验结果通常只能show，仅当写了定理、性质及其证明过程, 才能说 prove）。 解决英文句子语法问题好的中文 &#x3D; 好的英文。 句子的背后都是正确的逻辑。 可以使用charGPT来润色句子（注意专业术语），但不要用来生成句子。 两种方法写出好的句子： 借鉴法（推荐使用）基本步骤： 寻找相关方向的顶刊论文（打磨得更好）。 找出各部分的简单句子。 得到句型 注意事项： 按照一定的方式（句子基本结构，出现的介词，出现的位置等）来分别总结（方便查找和使用）。 不要使用从句（复杂句式），不便于理解。 优缺点： 优点：写的句子基本没有语法错误，使用总结的句式也很快。 缺点：需要积累很多句式，建议第一篇论文先花一周总结两百多个句式。 倒腾法基本步骤： 写一个英文句子。 使用翻译网站（百度、谷歌）翻译成中文。 再翻译成英文，直到中英文句子都不再改变。 再将剧中的非专业词汇替换为正确的专业词汇。 注意事项： 最好从英文句子开始。 如果最终的句子和最初写的句子相差太大，且没有正确表达想要表达的意思，需要根据最初的句子对最终的句子进行修改。 优缺点： 优点：可以按照自己的意思来写。 缺点：中文表达可能很差，导致最终句子还是不合格，很花时间。 符号系统不要对论文中的公式、符号进行额外的、特殊的处理。 严禁在word中使用公式编辑器编写公式，再转到Latex中。 注意一篇论文符号系统的一致性，不要出现一个符号代表两种意思的情况。 不同字体的同一个字母表示不同的涵义。 一个公式有编号就能使用（通过交叉引用）。 数学表达式太长，应将它进行切分。 文字中的数值均使用 $$ 括起来，与纯文字有点差别。 使用千分位 (1&#x2F;4 空格 \\,) 的作用: $123,456.789,01$ 的效果如下：$$123,456.789,01$$数值与单位之间也使用千分位分开, 且单位用正体. 如: $35$,m, $20$,kg 可以通过已发表论文中的tex文件来学习数学表达式。","tags":["论文写作"],"categories":["课程"]},{"title":"论文略读","path":"/2024/10/22/论文略读/","content":"Wings: Efficient Online Multiple Graph Pattern Matching实现了一个分布式系统，用于在线多图模式匹配。 采用有向无环图（DAG）来解决查询优化问题（许多查询图可能都有相同的查询子图，导致出现重复计算），从DAG中生成最优的查询计划。DAG中的节点是多个查询的子图模式。 采用渐进策略来进一步修剪DAG，用以评估查询路径的成本。 采用小批量的深度优先查询执行策略，来解决仍可能在匹配阶段才出现的重复匹配，导致产生大量中间结果，导致内存占用高。 Time-Constrained Continuous Subgraph Matching Using Temporal Information for Filtering and Backtracking提出了一种过滤技术和修剪技术，用于时间约束下的连续子图匹配。（即在时间数据图上找到与时间查询图同构且满足时间查询图顺序的所有匹配）。","tags":["论文"]},{"title":"最优化理论与方法","path":"/2024/10/16/最优化理论与方法/","content":"绪论最优化问题概述最优化的数学模型一般形式标准形式最优化问题分类经典优化问题(静态优化问题)根据数学模型中有无约束函数分为有约束的最优化问题和无约束的最优化问题;根 据目标函数和约束函数的函数类型分类:线性最优化问题(整数规划、0－1规划)、非线性最优化问题、二次规划、多目标规划。 现代优化问题（动态优化问题动态规划与最优控制问题组合优化问题","categories":["课程"]},{"title":"Discovering Association Rules from Big Graphs","path":"/2024/10/14/Discovering-Association-Rules-from-Big-Graphs/","content":"阅读方法： 首先，看摘要，了解这几篇论文解决了什么问题； 然后，看例子（examples），更加直观的理解所要解决的问题； 接着，看定义，理解问题的形式化（严谨）定义； 最后，试着理解算法，以及实验的大致内容 面临问题发现图规则的两个挑战： 返回过多规则 无法很好地扩展到大规模图上 解决方法采取了三种策略来解决问题： Application-driven rule discovery（应用驱动策略）：通过机器学习模型，削减那些与用户兴趣无关的规则和数据。 Sampling big graphs（采样大图）：由于经应用驱动策略削减后的数据仍然可能很大，所以还需采样。需要考虑采样率，召回率和支持度。 Parallel scalability（并行扩展）：保证可以使用并行的方法，确保能够在大图上使用。","categories":["论文阅读"]},{"title":"1750.删除字符串两端相同字符后的最短长度","path":"/2024/10/10/1750-删除字符串两端相同字符后的最短长度/","content":"题目给你一个只包含字符 &#39;a&#39;，&#39;b&#39; 和 &#39;c&#39; 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次： 选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。 选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。 前缀和后缀在字符串中任意位置都不能有交集。 前缀和后缀包含的所有字符都要相同。 同时删除前缀和后缀。 请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。 示例 1： 123输入：s = &quot;ca&quot;输出：2解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。 示例 2： 1234567输入：s = &quot;cabaabac&quot;输出：0解释：最优操作序列为：- 选择前缀 &quot;c&quot; 和后缀 &quot;c&quot; 并删除它们，得到 s = &quot;abaaba&quot; 。- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;baab&quot; 。- 选择前缀 &quot;b&quot; 和后缀 &quot;b&quot; 并删除它们，得到 s = &quot;aa&quot; 。- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;&quot; 。 示例 3： 12345输入：s = &quot;aabccabba&quot;输出：3解释：最优操作序列为：- 选择前缀 &quot;aa&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;bccabb&quot; 。- 选择前缀 &quot;b&quot; 和后缀 &quot;bb&quot; 并删除它们，得到 s = &quot;cca&quot; 。 提示： 1 &lt;= s.length &lt;= 105 s 只包含字符 &#39;a&#39;，&#39;b&#39; 和 &#39;c&#39; 。 题解12345678910111213141516171819class Solution &#123; public int minimumLength(String s) &#123; char[] ss = s.toCharArray(); int n = s.length(); int count = n; char p; int left,right; for(left=0,right=n-1;left&lt;right&amp;&amp;ss[left]==ss[right];)&#123; p=ss[left]; while(left&lt;=right&amp;&amp;p==ss[left])&#123;// 注意这里要把边界判断放前面，防止数组访问越界（如：&quot;bbbbbbbbbbbbbbbbbbb&quot;）。 left++; &#125; while(left&lt;=right&amp;&amp;p==ss[right])&#123; right--; &#125; &#125; return right-left+1; &#125;&#125; 知识点注意边界判断，防止越界。","tags":["算法"],"categories":["LeetCode","单序列双指针_相向双指针"]},{"title":"系统环境小命令","path":"/2024/10/09/系统环境小命令/","content":"Pytorch版本1conda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia","tags":["环境"],"categories":["积累"]},{"title":"209.长度最小的子数组","path":"/2024/10/08/209-长度最小的子数组/","content":"题目给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 题解12345678910111213141516class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int sum=0; int n=nums.length; int ans=n+1; for(int right=0, left=0;right&lt;n;right++)&#123; sum+=nums[right]; while(sum&gt;=target)&#123; ans = Math.min(ans,right-left+1); sum-=nums[left]; left++; &#125; &#125; return ans &lt;= n ? ans : 0; &#125;&#125; 知识点注意考虑何时更新结果，以及返回值的判定（子数组就是它本身，以及找不到这样的子数组）。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最短/最小"]},{"title":"Windows文件夹快捷图标变为英文一键修复","path":"/2024/09/27/Windows文件夹快捷图标变为英文一键修复/","content":"起因由于Win11抽风，OneDrive自动同步，导致今天打开电脑，桌面上出现了很多以前账号的旧文件，同时导致Windows桌面文件夹路径发生改变，变成在OneDrive文件夹下。 解决将OneDrive卸载后，将文件夹移除到原位置或删除。发现桌面文件夹名字在路径中不会自动变成英文。于是在网上寻找解决方案，发现了文件夹修复脚本，可以将文件夹路径改成英文且显示中文，还能创建误删的文件夹。（修复过后需要将原来的文件夹的内容手动移到新文件夹中。） .bat程序代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144@echo offtitle 常见特殊文件夹修复工具cd /d “%~dp0”:beginclsecho ****************************************echo.echo 请选择要修复的特殊文件夹echo.echo [1] 桌面 [2] 图片 [3] 视频echo [4] 文档 [5] 下载 [6] 音乐echo [7] 3D 对象 [8] Roaming [0] 退出echo.echo _________________________________________echo.set /p num=请输入你的选择（0-8）：if &quot;%num%&quot;==&quot;1&quot; goto zmif &quot;%num%&quot;==&quot;2&quot; goto tpif &quot;%num%&quot;==&quot;3&quot; goto spif &quot;%num%&quot;==&quot;4&quot; goto wdif &quot;%num%&quot;==&quot;5&quot; goto xzif &quot;%num%&quot;==&quot;6&quot; goto yyif &quot;%num%&quot;==&quot;7&quot; goto 3dif &quot;%num%&quot;==&quot;8&quot; goto rmif &quot;%num%&quot;==&quot;0&quot; goto tcgoto begin:zmset folder=&quot;桌面&quot;set ini=&quot;desktop&quot;set name=&quot;Desktop&quot;set value=&quot;%USERPROFILE%\\Desktop&quot;set valueex=&quot;%%USERPROFILE%%\\Desktop&quot;set clsid=&quot;&#123;754AC886-DF64-4CBA-86B5-F7FBF4FBCEF5&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:tpset folder=&quot;图片&quot;set ini=&quot;Pictures&quot;set name=&quot;My Pictures&quot;set value=&quot;%USERPROFILE%\\Pictures&quot;set valueex=&quot;%%USERPROFILE%%\\Pictures&quot;set clsid=&quot;&#123;0DDD015D-B06C-45D5-8C4C-F59713854639&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:spset folder=&quot;视频&quot;set ini=&quot;Videos&quot;set name=&quot;My Video&quot;set value=&quot;%USERPROFILE%\\Videos&quot;set valueex=&quot;%%USERPROFILE%%\\Videos&quot;set clsid=&quot;&#123;35286A68-3C57-41A1-BBB1-0EAE73D76C95&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:wdset folder=&quot;文档&quot;set ini=&quot;Documents&quot;set name=&quot;Personal&quot;set value=&quot;%USERPROFILE%\\Documents&quot;set valueex=&quot;%%USERPROFILE%%\\Documents&quot;set clsid=&quot;&#123;F42EE2D3-909F-4907-8871-4C22FC0BF756&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:xzset folder=&quot;下载&quot;set ini=&quot;Downloads&quot;set name=&quot;&#123;374DE290-123F-4565-9164-39C4925E467B&#125;&quot;set value=&quot;%USERPROFILE%\\Downloads&quot;set valueex=&quot;%%USERPROFILE%%\\Downloads&quot;set clsid=&quot;&#123;7d83ee9b-2244-4e70-b1f5-5393042af1e4&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:yyset folder=&quot;音乐&quot;set ini=&quot;Music&quot;set name=&quot;My Music&quot;set value=&quot;%USERPROFILE%\\Music&quot;set valueex=&quot;%%USERPROFILE%%\\Music&quot;set clsid=&quot;&#123;A0C69A99-21C8-4671-8703-7934162FCF1D&#125;&quot;call :fixsubecho.&amp;pause&amp;goto begin:3dset folder=&quot;3D 对象&quot;set ini=&quot;3D Objects&quot;set name=&quot;&#123;31C0DD25-9439-4F12-BF41-7FF4EDA38722&#125;&quot;set value=&quot;%USERPROFILE%\\3D Objects&quot;set valueex=&quot;%%USERPROFILE%%\\3D Objects&quot;set clsid=&quot;&quot;call :fixsubecho.&amp;pause&amp;goto begin:rmset folder=&quot;Roaming&quot;set ini=&quot;&quot;set name=&quot;AppData&quot;set value=&quot;%USERPROFILE%\\AppData\\Roaming&quot;set valueex=&quot;%%USERPROFILE%%\\AppData\\Roaming&quot;set clsid=&quot;&quot;reg add &quot;HKEY_CURRENT_USER\\Volatile Environment&quot; /v %name% /t reg_sz /d %value% /fcall :fixsubecho.&amp;pause&amp;goto begin:tcexit:fixsubecho.echo 修复%folder%文件夹echo.echo 结束桌面进程...taskkill /f /im explorer.exeecho.echo 创建文件夹%value%...mkdir %value%echo.if %ini% neq &quot;&quot; (echo 修复desktop.ini文件...attrib -s -h -r -a %value%\\desktop.iniecho y | xcopy %ini%\\desktop.ini %value%\\ /-Y /A /Hattrib +s +h +a %value%\\desktop.iniattrib +r %value%echo.)echo 修复Shell Folders下%name%的路径...reg add &quot;HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders&quot; /v %name% /t reg_sz /d %value% /fecho.echo 修复User Shell Folders下%name%的路径...reg add &quot;HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders&quot; /v %name% /t reg_expand_sz /d %valueex% /fecho.if %clsid% neq &quot;&quot; (echo 删除User Shell Folders下的%clsid%...reg delete &quot;HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders&quot; /v %clsid% /f 2&gt;nul)echo.echo 重启桌面进程...start explorer.exeecho.goto :eof","tags":["Windows"],"categories":["脚本"]},{"title":"2516.每种字符至少取 K 个","path":"/2024/09/25/2516-每种字符至少取-K-个/","content":"题目给你一个由字符 &#39;a&#39;、&#39;b&#39;、&#39;c&#39; 组成的字符串 s 和一个非负整数 k 。每分钟，你可以选择取走 s 最左侧 还是 最右侧 的那个字符。 你必须取走每种字符 至少 k 个，返回需要的 最少 分钟数；如果无法取到，则返回 -1 。 示例 1： 1234567输入：s = &quot;aabaaaacaabc&quot;, k = 2输出：8解释：从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。共需要 3 + 5 = 8 分钟。可以证明需要的最少分钟数是 8 。 示例 2： 123输入：s = &quot;a&quot;, k = 1输出：-1解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 -1 。 提示： 1 &lt;= s.length &lt;= 105 s 仅由字母 &#39;a&#39;、&#39;b&#39;、&#39;c&#39; 组成 0 &lt;= k &lt;= s.length 题解123456789101112131415161718192021222324252627282930class Solution &#123; public int takeCharacters(String s, int k) &#123; int[] remains = new int[3]; // 每个字符取k个后，应剩余的个数 int[] counts = new int[3]; // 该字符串中每个字符的个数 int n=s.length(); for(int i=0;i&lt;n;i++)&#123; char c = s.charAt(i); counts[c-&#x27;a&#x27;]++; &#125; // 不满足取的条件 for(int i=0;i&lt;3;i++)&#123; remains[i]= counts[i]-k; if(remains[i]&lt;0)&#123; return -1; &#125; &#125; int ans=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c=s.charAt(right); // 该字符在剩余字符串中 remains[c-&#x27;a&#x27;]--; while(remains[c-&#x27;a&#x27;]&lt;0)&#123; char p = s.charAt(left); remains[p-&#x27;a&#x27;]++; left++; &#125; ans = Math.max(ans,right-left+1); &#125; return n-ans; &#125;&#125; 知识点逆向思维 + 滑动窗口 由于每次都是从最左侧 或 最右侧 取字符，剩下的肯定是子字符串，所以可以使用滑动窗口。 需要返回的 最少 分钟数，即剩下的字符串最长，还要保证取走的字符满足个数要求，也就是还需要考虑剩下的字符串中的字符个数要求。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1838.最高频元素的频数","path":"/2024/09/24/1838-最高频元素的频数/","content":"题目元素的 频数 是该元素在一个数组中出现的次数。 给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。 执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。 示例 1： 1234输入：nums = [1,2,4], k = 5输出：3解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。4 是数组中最高频元素，频数是 3 。 示例 2： 123456输入：nums = [1,4,8,13], k = 5输出：2解释：存在多种最优解决方案：- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。 示例 3： 12输入：nums = [3,9,6], k = 2输出：1 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= 105 题解12345678910111213141516171819class Solution &#123; public int maxFrequency(int[] nums, int k) &#123; int n=nums.length; Arrays.sort(nums); int ans=1; long count=0; for(int right=1,left=0;right&lt;n;right++)&#123; count+=(long)(nums[right]-nums[right-1])*(right-left); while(count&gt;k&amp;&amp;left&lt;=right)&#123; count-=nums[right]-nums[left]; left++; &#125; ans=Math.max(ans,right-left+1); &#125; return ans; &#125;&#125; 知识点题目翻译：求一个数组中，如何使用给定的次数k，将数组中某些元素执行k次的加1操作，使得数组中相同元素尽可能地多。结果要的是这个元素的频数。 应当对【离我们选定的最高频元素最近的元素】进行加1操作。这个最近指的是，差值最近。经过排序后，也就是距离最近。 再次翻译题目：如何在有限的k次操作中，尽可能多的让某个区间中的值相等，求这个最长区间的长度。使用滑动窗口。 操作数的计算公式：count += (long)(nums[right] - nums[right - 1]) * (right - left);注意：这里需要强制转换为long，不然会溢出有样例过不了。 图解如下：","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1658.将 x 减到 0 的最小操作数","path":"/2024/09/23/1658-将-x-减到-0-的最小操作数/","content":"题目给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。 示例 1： 123输入：nums = [1,1,4,2,3], x = 5输出：2解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2： 12输入：nums = [5,6,7,8,9], x = 4输出：-1 示例 3： 123输入：nums = [3,2,20,1,1,3], x = 10输出：5解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 1 &lt;= x &lt;= 109 题解123456789101112131415161718192021222324252627class Solution &#123; public int minOperations(int[] nums, int x) &#123; long sum =0; int n = nums.length; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; &#125; long target = sum-x; if(target&lt;0)&#123; return -1; &#125; int ans=-1; long sum1 = 0; for(int left=0,right=0;right&lt;n;right++)&#123; sum1+=nums[right]; while(sum1&gt;target)&#123; sum1-=nums[left]; left++; &#125; if(target==sum1)&#123; ans = Math.max(ans,right-left+1); &#125; &#125; return ans==-1?ans:n-ans; &#125;&#125; 知识点思路：逆向思维，滑动窗口 每次都是移除数组 nums 最左边或最右边的元素，剩下的数组肯定是子数组。因此，想到使用滑动窗口。 求的是最小操作数，即剩下的子数组长度最长且子数组和为原数组和减x。 注意需要判断特殊情况：x比原数组和还大。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2779.数组的最大美丽值","path":"/2024/09/20/2779-数组的最大美丽值/","content":"题目给你一个下标从 0 开始的整数数组 nums 和一个 非负 整数 k 。 在一步操作中，你可以执行下述指令： 在范围 [0, nums.length - 1] 中选择一个 此前没有选过 的下标 i 。 将 nums[i] 替换为范围 [nums[i] - k, nums[i] + k] 内的任一整数。 数组的 美丽值 定义为数组中由相等元素组成的最长子序列的长度。 对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。 注意：你 只 能对每个下标执行 一次 此操作。 数组的 子序列 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。 示例 1： 1234567输入：nums = [4,6,1,2], k = 2输出：3解释：在这个示例中，我们执行下述操作：- 选择下标 1 ，将其替换为 4（从范围 [4,8] 中选出），此时 nums = [4,4,1,2] 。- 选择下标 3 ，将其替换为 4（从范围 [0,4] 中选出），此时 nums = [4,4,1,4] 。执行上述操作后，数组的美丽值是 3（子序列由下标 0 、1 、3 对应的元素组成）。可以证明 3 是我们可以得到的由相等元素组成的最长子序列长度。 示例 2： 1234输入：nums = [1,1,1,1], k = 10输出：4解释：在这个示例中，我们无需执行任何操作。数组 nums 的美丽值是 4（整个数组）。 提示： 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i], k &lt;= 105 题解1234567891011121314151617181920class Solution &#123; public int maximumBeauty(int[] nums, int k) &#123; Arrays.sort(nums); int n=nums.length; int count=0; int ans=0; for(int left=0,right=0;right&lt;n;right++)&#123; // System.out.println(nums[right]); count++; while((nums[left]+k &lt; nums[right]-k )&amp;&amp;left&lt;right)&#123; left++; count--; &#125; ans=Math.max(ans,count); &#125; return ans; &#125; &#125; 知识点排序 + 滑动窗口 根据子序列和美丽值的定义可知：最终所求结果和元素顺序无关。因此，可以将原数组排序，得到如下图的区间图： 题目所求的相等元素组成的最长子序列，相当于选出若干闭区间，交集不为空。 经过排序后，区间是连续的，只需考虑最左边区间[left−k,left+k]和最右边区间[right−k,right+k]的交集不为空，即可保证之间的这些区间也不为空，即：left+k &gt;= right-k。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2958.最多 K 个重复元素的最长子数组","path":"/2024/09/20/2958-最多-K-个重复元素的最长子数组/","content":"题目给你一个整数数组 nums 和一个整数 k 。 一个元素 x 在数组中的 频率 指的是它在数组中的出现次数。 如果一个数组中所有元素的频率都 小于等于 k ，那么我们称这个数组是 好 数组。 请你返回 nums 中 最长好 子数组的长度。 子数组 指的是一个数组中一段连续非空的元素序列。 示例 1： 1234输入：nums = [1,2,3,1,2,3,1,2], k = 2输出：6解释：最长好子数组是 [1,2,3,1,2,3] ，值 1 ，2 和 3 在子数组中的频率都没有超过 k = 2 。[2,3,1,2,3,1] 和 [3,1,2,3,1,2] 也是好子数组。最长好子数组的长度为 6 。 示例 2： 1234输入：nums = [1,2,1,2,1,2,1,2], k = 1输出：2解释：最长好子数组是 [1,2] ，值 1 和 2 在子数组中的频率都没有超过 k = 1 。[2,1] 也是好子数组。最长好子数组的长度为 2 。 示例 3： 1234输入：nums = [5,5,5,5,5,5,5], k = 4输出：4解释：最长好子数组是 [5,5,5,5] ，值 5 在子数组中的频率没有超过 k = 4 。最长好子数组的长度为 4 。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 1 &lt;= k &lt;= nums.length 题解12345678910111213141516171819class Solution &#123; public int maxSubarrayLength(int[] nums, int k) &#123; int ans=0; int n=nums.length; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int left=0,right=0;right&lt;n;right++)&#123; map.merge(nums[right],1,Integer::sum); while(map.get(nums[right])&gt;k)&#123; map.merge(nums[left],-1,Integer::sum); if(map.get(nums[left])==0)&#123; map.remove(nums[left]); &#125; left++; &#125; ans=Math.max(ans,right-left+1); &#125; return ans; &#125;&#125; 知识点简单题，只需使用哈希表和滑动窗口。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1695.删除子数组的最大得分","path":"/2024/09/20/1695-删除子数组的最大得分/","content":"题目给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。 返回 只删除一个 子数组可获得的 最大得分 。 如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。 示例 1： 123输入：nums = [4,2,4,5,6]输出：17解释：最优子数组是 [2,4,5,6] 示例 2： 123输入：nums = [5,2,1,2,5,2,1,2,5]输出：8解释：最优子数组是 [5,2,1] 或 [1,2,5] 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 题解12345678910111213141516171819202122class Solution &#123; public int maximumUniqueSubarray(int[] nums) &#123; int n=nums.length; int ans=0; int count=0; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int left=0,right=0;right&lt;n;right++)&#123; map.put(nums[right],map.getOrDefault(nums[right],0)+1); count+=nums[right]; while(map.size()&lt;right-left+1)&#123; map.merge(nums[left],-1,Integer::sum); count-=nums[left]; if(map.get(nums[left])==0)&#123; map.remove(nums[left]); &#125; left++; &#125; ans=Math.max(ans,count); &#125; return ans; &#125;&#125; 知识点主要是怎么判断若干个不同元素的子数组。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"904.水果成篮","path":"/2024/09/19/904-水果成篮/","content":"题目你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length 题解1234567891011121314151617181920212223class Solution &#123; public int totalFruit(int[] fruits) &#123; int ans=0; int n=fruits.length; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int left=0,right=0;right&lt;n;right++)&#123; while(map.size()&gt;2&amp;&amp;left&lt;=right)&#123; map.merge(fruits[left], -1, Integer::sum); if(map.get(fruits[left])==0)&#123; map.remove(fruits[left]); &#125; left++; &#125; map.merge(fruits[right], 1, Integer::sum); if(map.size()&lt;=2)&#123; ans=Math.max(ans,right-left+1); &#125; &#125; return ans; &#125;&#125; 知识点磕绊地方：更新结果时。没加判断会导致多出一个。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2730.找到最长的半重复子字符串","path":"/2024/09/18/2730-找到最长的半重复子字符串/","content":"题目给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。 如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串 t 是 半重复的 。例如，&quot;0010&quot; 、&quot;002020&quot; 、&quot;0123&quot; 、&quot;2002&quot; 和 &quot;54944&quot; 是半重复字符串，而 &quot;00101022&quot; （相邻的相同数字对是 00 和 22）和 &quot;1101234883&quot; （相邻的相同数字对是 11 和 88）不是半重复字符串。 请你返回 s 中最长 半重复 子字符串 的长度。 示例 1： 输入：s &#x3D; “52233” 输出：4 解释： 最长的半重复子字符串是 “5223”。整个字符串 “52233” 有两个相邻的相同数字对 22 和 33，但最多只能选取一个。 示例 2： 输入：s &#x3D; “5494” 输出：4 解释： s 是一个半重复字符串。 示例 3： 输入：s &#x3D; “1111111” 输出：2 解释： 最长的半重复子字符串是 “11”。子字符串 “111” 有两个相邻的相同数字对，但最多允许选取一个。 提示： 1 &lt;= s.length &lt;= 50 &#39;0&#39; &lt;= s[i] &lt;= &#39;9&#39; 题解12345678910111213141516171819202122class Solution &#123; public int longestSemiRepetitiveSubstring(String s) &#123; int ans=1; var s1 = s.toCharArray(); int n=s1.length; int same=0; for(int l=0,r=1;r&lt;n;r++)&#123; if(s1[r]==s1[r-1])&#123; same++; &#125; if(same&gt;1)&#123; l++; while(s1[l]!=s1[l-1])&#123; l++; &#125; same--; &#125; ans = Math.max(ans,r-l+1); &#125; return ans; &#125;&#125; 知识点还是搞不懂怎么滑的问题。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1208.尽可能使字符串相等","path":"/2024/09/17/1208-尽可能使字符串相等/","content":"题目给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例 1： 123输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3输出：3解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。 示例 2： 123输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3输出：1解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。 示例 3： 123输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0输出：1解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。 提示： 1 &lt;= s.length, t.length &lt;= 10^5 0 &lt;= maxCost &lt;= 10^6 s 和 t 都只含小写英文字母。 题解1234567891011121314151617181920212223class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; // 将字符串转换为字符数组 char[] s1 = s.toCharArray(); char[] t1 = t.toCharArray(); int count=0; int n=s.length(); int[] costs = new int[n]; for(int i=0;i&lt;n;i++)&#123; costs[i]=Math.abs(s1[i]-t1[i]); &#125; int cost=0; for(int left=0,right=0;right&lt;n;right++)&#123; cost+=costs[right]; while(cost&gt;maxCost)&#123; cost-=costs[left]; left++; &#125; count=Math.max(count,right-left+1); &#125; return count; &#125;&#125; 知识点看到子字符串，联想到使用滑动窗口。但是滑动窗口需要在同一个存储空间才能滑，结合条件：每个字符串长度相同，且有预算要求。因此，想到在这两个字符串转变的花费数组上进行滑动。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1493.删掉一个元素以后全为 1 的最长子数组","path":"/2024/09/17/1493-删掉一个元素以后全为-1-的最长子数组/","content":"题目给你一个二进制数组 nums ，你需要从中删掉一个元素。 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。 如果不存在这样的子数组，请返回 0 。 提示 1： 123输入：nums = [1,1,0,1]输出：3解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。 示例 2： 123输入：nums = [0,1,1,1,0,1,1,0,1]输出：5解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。 示例 3： 123输入：nums = [1,1,1]输出：2解释：你必须要删除一个元素。 提示： 1 &lt;= nums.length &lt;= 105 nums[i] 要么是 0 要么是 1 。 题解1234567891011121314151617class Solution &#123; public int longestSubarray(int[] nums) &#123; int n=nums.length; int count=0; int ans=0; for(int right=0,left=0;right&lt;n;right++)&#123; count+=1-nums[right]; while(count&gt;1&amp;&amp;left&lt;=right)&#123; count-=1-nums[left]; left++; &#125; ans = Math.max(ans,right-left); &#125; return ans; &#125;&#125; 知识点这题是1004. 最大连续1的个数 III的特例，即k=1。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"1004.最大连续1的个数 III","path":"/2024/09/17/1004-最大连续1的个数-III/","content":"题目给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。 示例 1： 1234输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释：[1,1,1,0,0,1,1,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2： 1234输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3输出：10解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示： 1 &lt;= nums.length &lt;= 105 nums[i] 不是 0 就是 1 0 &lt;= k &lt;= nums.length 题解12345678910111213141516class Solution &#123; public int longestOnes(int[] nums, int k) &#123; int n=nums.length; int ans=0; int count=0;// 记录0的个数 for(int left=0,right=0;right&lt;n;right++)&#123; count+=1-nums[right]; while(count&gt;k&amp;&amp;left&lt;=right)&#123; count-=1-nums[left]; left++; &#125; ans = Math.max(ans,right-left+1); &#125; return ans; &#125;&#125; 知识点题意转换：把「最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度」转换为 「找出一个最长的子数组，该子数组内最多允许有 K 个 0 」。 求最大连续子区间，可以使用滑动窗口方法。 滑动窗口的限制条件是：窗口内最多有 K 个 0。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"3090.每个字符最多出现两次的最长子字符串","path":"/2024/09/14/3090-每个字符最多出现两次的最长子字符串/","content":"题目给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该 子字符串 的 最大 长度。 示例 1： 输入： s &#x3D; “bcbbbcba” 输出： 4 解释： 以下子字符串长度为 4，并且每个字符最多出现两次：&quot;bcbbbcba&quot;。 示例 2： 输入： s &#x3D; “aaaa” 输出： 2 解释： 以下子字符串长度为 2，并且每个字符最多出现两次：&quot;aaaa&quot;。 提示： 2 &lt;= s.length &lt;= 100 s 仅由小写英文字母组成。 题解1234567891011121314151617class Solution &#123; public int maximumLengthSubstring(String s) &#123; int n=s.length(); HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int len=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c = s.charAt(right); while(left&lt;right&amp;&amp;map.getOrDefault(c, 0) == 2)&#123; map.put(s.charAt(left),map.get(s.charAt(left))-1); left++; &#125; map.put(c,map.getOrDefault(c, 0)+1); len=Math.max(len,right-left+1); &#125; return len; &#125;&#125; 不太优雅，使用merge 123456789101112131415161718class Solution &#123; public int maximumLengthSubstring(String s) &#123; //滑动窗口 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int res = 0; int left = 0; for(int right = 0; right &lt; s.length(); right++) &#123; char ch = s.charAt(right); while(map.getOrDefault(ch, 0) &gt;= 2) &#123; map.merge(s.charAt(left), -1, Integer::sum);//left对应字符个数减少1 left++; &#125; map.merge(ch, 1, Integer::sum); res = Math.max(res, right - left + 1); &#125; return res; &#125;&#125; 知识点Map 接口的 merge 方法允许你在给定的键不存在的情况下插入一个新值，或者当键已经存在时应用合并函数。 1V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) 参数 key: 要插入或更新的键。 value: 如果键不存在，则插入的默认值。 remappingFunction: 如果键已存在，则应用的合并函数。这个函数接受两个参数，一个是当前映射的值，另一个是默认值，并返回一个新的值。 Integer::sum 作为合并函数，这是一个引用 Integer 类的静态方法 sum 的方法引用。Integer::sum 接受两个 int 参数并返回它们的和。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"3.无重复字符的最长子串","path":"/2024/09/14/3-无重复字符的最长子串/","content":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题解123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;(); int n=s.length(); int len=0; for(int left=0,right=0;right&lt;n;right++)&#123; char c = s.charAt(right); while(left&lt;right&amp;&amp;set.contains(c))&#123; //存在相同元素 set.remove(s.charAt(left)); left++; &#125; set.add(c); len=Math.max(len,right-left+1); &#125; return len; &#125;&#125; 知识点滑动窗口模板： 12345678//外层循环扩展右边界，内层循环扩展左边界for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;\t//当前考虑的元素\twhile (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意 //扩展左边界 &#125; //区间[left,right]符合题意，统计相关信息&#125; HashSet： 判断是否有重复的字符。","tags":["算法"],"categories":["LeetCode","不定长滑动窗口_求最长/最大"]},{"title":"2653.滑动子数组的美丽值","path":"/2024/09/13/2653-滑动子数组的美丽值/","content":"题目给你一个长度为 n 的整数数组 nums ，请你求出每个长度为 k 的子数组的 美丽值 。 一个子数组的 美丽值 定义为：如果子数组中第 x 小整数 是 负数 ，那么美丽值为第 x 小的数，否则美丽值为 0 。 请你返回一个包含 n - k + 1 个整数的数组，依次 表示数组中从第一个下标开始，每个长度为 k 的子数组的 美丽值 。 子数组指的是数组中一段连续 非空 的元素序列。 示例 1： 123456输入：nums = [1,-1,-3,-2,3], k = 3, x = 2输出：[-1,-2,-2]解释：总共有 3 个 k = 3 的子数组。第一个子数组是 [1, -1, -3] ，第二小的数是负数 -1 。第二个子数组是 [-1, -3, -2] ，第二小的数是负数 -2 。第三个子数组是 [-3, -2, 3] ，第二小的数是负数 -2 。 示例 2： 1234567输入：nums = [-1,-2,-3,-4,-5], k = 2, x = 2输出：[-1,-2,-3,-4]解释：总共有 4 个 k = 2 的子数组。[-1, -2] 中第二小的数是负数 -1 。[-2, -3] 中第二小的数是负数 -2 。[-3, -4] 中第二小的数是负数 -3 。[-4, -5] 中第二小的数是负数 -4 。 示例 3： 12345678输入：nums = [-3,1,2,-3,0,-3], k = 2, x = 1输出：[-3,0,-3,-3,-3]解释：总共有 5 个 k = 2 的子数组。[-3, 1] 中最小的数是负数 -3 。[1, 2] 中最小的数不是负数，所以美丽值为 0 。[2, -3] 中最小的数是负数 -3 。[-3, 0] 中最小的数是负数 -3 。[0, -3] 中最小的数是负数 -3 。 提示： n == nums.length 1 &lt;= n &lt;= 105 1 &lt;= k &lt;= n 1 &lt;= x &lt;= k -50 &lt;= nums[i] &lt;= 50 题解123456789101112131415161718192021222324class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n=nums.length; int[] bn = new int[n-k+1]; int[] count = new int[50*2+1]; for(int i=0;i&lt;k-1;i++)&#123; count[nums[i]+50]++;// 由于nums中的数很小，所以采用计数排序。 &#125; int x1; for(int i=k-1;i&lt;n;i++)&#123; count[nums[i]+50]++; x1=x; for(int j=0;j&lt;50;j++)&#123;// 因为看的是负数，所以只需要遍历负数。 x1-=count[j];// 重点在于这里。 if(x1&lt;=0)&#123; bn[i-(k-1)]=j-50; break; &#125; &#125; count[nums[i-(k-1)]+50]--; &#125; return bn; &#125;&#125; 123456789101112131415161718192021222324252627// 自己开始写的超时了。我的思路是将窗口中的数排序，采用的方法是先转换为列表（因为列表直接添加和删除顺序不变），再由列表转为数组，再采用Arrays.sort()进行排序，取第x个数进行判断。// TODO 暂时还没想到改进方法class Solution &#123; public int[] getSubarrayBeauty(int[] nums, int k, int x) &#123; int n=nums.length; int[] temp = new int[k]; int[] b = new int[n-k+1]; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int count=0; for(int i=0;i&lt;n;i++)&#123; list.add(nums[i]); if(i&lt;k-1)&#123; continue; &#125; temp = list.stream().mapToInt(Integer::intValue).toArray(); Arrays.sort(temp); if(temp[x-1]&lt;0)&#123; b[count]=temp[x-1]; &#125;else&#123; b[count]=0; &#125; count++; list.remove(Integer.valueOf(nums[i-(k-1)])); &#125; return b; &#125;&#125; 知识点滑动窗口 + 计数排序。 思路：在于如何理解第x小的数。 假设第x小的数为num，那么小于num的数的个数肯定小于x，大于num的数的个数肯定大于等于x。两个条件结合才能保证num为第x小的数。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"国内镜像源","path":"/2024/09/13/国内镜像源/","content":"pip常用镜像源清华大学 1https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 1https://mirrors.aliyun.com/pypi/simple/ 网易 1https://mirrors.163.com/pypi/simple/ 豆瓣 1https://pypi.mirrors.ustc.edu.cn/simple/ 中科大 1https://pypi.mirrors.ustc.edu.cn/simple/","categories":["积累"]},{"title":"Anaconda环境创建与卸载","path":"/2024/09/13/Anaconda环境创建与卸载/","content":"环境创建1conda create -n XXX python=3.9 环境删除1conda remove -n XXX --all 环境激活1conda activate XXX 环境查看1conda env list","tags":["Anaconda"],"categories":["技巧"]},{"title":"1423.可获得的最大点数","path":"/2024/09/13/1423-可获得的最大点数/","content":"题目几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 123输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 123输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 123输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 123输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 12输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length 题解12345678910111213141516171819202122232425class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int sum=0; int all=0; int min=Integer.MAX_VALUE; int n=cardPoints.length; int m=n-k;// 新窗口 for(int i=0;i&lt;n;i++) &#123; all += cardPoints[i]; &#125; if(m==0)&#123; return all; &#125;else&#123; for(int i=0;i&lt;n;i++)&#123; sum+=cardPoints[i]; if(i&lt;m-1)&#123; continue; &#125; min = Math.min(min,sum); sum-=cardPoints[i-(m-1)]; &#125; return all-min; &#125; &#125;&#125; 知识点思路：逆向思维。 首先，将问题判断为定长滑动窗口问题：虽然，每次拿牌都可以从开头或者末尾拿一张，总共要拿k张牌。但是，所剩余的牌必定是n-k张（n为牌的总数），且剩余的牌必定是连续的。 然后，要使得拿走的牌点数和最大，那么就意味着剩下的连续牌点数最小。 最后，问题变成求n-k长的子数组和的最小值。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"Hexo博客文档间跳转","path":"/2024/09/12/Hexo博客文档间跳转/","content":"Makdown语法同一目录下，可以这么写： 1[hello-world.Md](hello-world.md) 示例：hello-world.Md Hexo标签使用post_link标签&#123;% post_link 文件名 %&#125;或者&#123;% post_link 文件名 自定义标题 %&#125; 12&#123;% post_link hello-world %&#125;&#123;% post_link hello-world 你好世界 %&#125; 示例：Hello World 你好世界","tags":["Hexo"],"categories":["技巧"]},{"title":"2461.长度为 K 子数组中的最大和","path":"/2024/09/12/2461-长度为-K-子数组中的最大和/","content":"题目给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和： 子数组的长度是 k，且 子数组中的所有元素 各不相同 。 返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。 子数组 是数组中一段连续非空的元素序列。 示例 1： 123456789输入：nums = [1,5,4,2,9,9,9], k = 3输出：15解释：nums 中长度为 3 的子数组是：- [1,5,4] 满足全部条件，和为 10 。- [5,4,2] 满足全部条件，和为 11 。- [4,2,9] 满足全部条件，和为 15 。- [2,9,9] 不满足全部条件，因为元素 9 出现重复。- [9,9,9] 不满足全部条件，因为元素 9 出现重复。因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。 示例 2： 12345输入：nums = [4,4,4], k = 3输出：0解释：nums 中长度为 3 的子数组是：- [4,4,4] 不满足全部条件，因为元素 4 出现重复。因为不存在满足全部条件的子数组，所以返回 0 。 提示： 1 &lt;= k &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 题解1234567891011121314151617181920212223242526272829class Solution &#123; public long maximumSubarraySum(int[] nums, int k) &#123; int n=nums.length; long sum=0; long max=0; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); &#125;else&#123; map.put(nums[i],1); &#125; if(i&lt;k-1)&#123; continue; &#125; if(sum&gt;max &amp;&amp; map.size()==k)&#123; max=sum; &#125; sum-=nums[i-(k-1)]; if(map.get(nums[i-(k-1)])==1)&#123; map.remove(nums[i-(k-1)]); &#125;else&#123; map.put(nums[i-(k-1)],map.get(nums[i-(k-1)])-1); &#125; &#125; return max; &#125;&#125; 知识点和2841.几乎唯一子数组的最大和这篇文章基本一样，只是在更新时，判断有所不一样。 Hello World 你好世界","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2841.几乎唯一子数组的最大和","path":"/2024/09/12/2841-几乎唯一子数组的最大和/","content":"题目给你一个整数数组 nums 和两个正整数 m 和 k 。 请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。 如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。 子数组指的是一个数组中一段连续 非空 的元素序列。 示例 1： 123输入：nums = [2,6,7,3,1,7], m = 3, k = 4输出：18解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。 示例 2： 123输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3输出：23解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。 示例 3： 123输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3输出：0解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。 提示： 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= m &lt;= k &lt;= nums.length 1 &lt;= nums[i] &lt;= 109 题解12345678910111213141516171819202122232425262728293031class Solution &#123; public long maxSum(List&lt;Integer&gt; nums, int m, int k) &#123; HashMap&lt;Integer ,Integer&gt; map = new HashMap&lt;&gt;(); int n=nums.size(); long max=0; long sum=0; // 注意要使用long型，否则越界 for(int i=0;i&lt;n;i++)&#123; sum+=nums.get(i); if(map.containsKey(nums.get(i)))&#123; map.put(nums.get(i),map.get(nums.get(i))+1); &#125;else&#123; map.put(nums.get(i),1); &#125; if(i&lt;k-1)&#123; continue; &#125; // System.out.printlni&quot;map&quot;+map.size()); if(sum&gt;max&amp;&amp;map.size()&gt;=m)&#123; max=sum; &#125; sum-=nums.get(i-(k-1)); if(map.get(nums.get(i-(k-1)))==1)&#123; map.remove(nums.get(i-(k-1))); &#125;else&#123; map.put(nums.get(i-(k-1)),map.get(nums.get(i-(k-1)))-1); &#125; //map.remove(i-(k-1)); &#125; return max; &#125;&#125; 知识点思路：求子数组的 最大和是常规定长滑动窗口问题，这题对我来说难点在于如何判断唯一，我想到使用哈希表，它能保证键唯一。哈希表的键为该位置i的原数组的值，哈希表的值为该值在一个滑动窗口中出现的次数。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1052.爱生气的书店老板","path":"/2024/09/12/1052-爱生气的书店老板/","content":"题目有一个书店老板，他的书店开了 n 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 n 的整数数组 customers ，其中 customers[i] 是在第 i 分钟开始时进入商店的顾客数量，所有这些顾客在第 i 分钟结束后离开。 在某些分钟内，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 minutes 分钟不生气，但却只能使用一次。 请你返回 这一天营业下来，最多有多少客户能够感到满意 。 示例 1： 1234输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 示例 2： 12输入：customers = [1], grumpy = [0], minutes = 1输出：1 提示： n == customers.length == grumpy.length 1 &lt;= minutes &lt;= n &lt;= 2 * 104 0 &lt;= customers[i] &lt;= 1000 grumpy[i] == 0 or 1 题解1234567891011121314151617181920212223242526class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int minutes) &#123; int n=customers.length; int sum=0;// 记录老板不生气时的顾客数量 for(int i=0;i&lt;n;i++)&#123; if(grumpy[i]==0)&#123; sum+=customers[i]; &#125; &#125; int m = 0;// 记录3分钟内老板生气，离开的顾客数量最大值 int ns=0; for(int i=0;i&lt;n;i++)&#123; if(grumpy[i]==1)&#123; ns+=customers[i]; &#125; if(i&lt;minutes-1)&#123; continue; &#125; m = Math.max(m,ns); if(grumpy[i-(minutes-1)]==1)&#123; ns-=customers[i-(minutes-1)]; &#125; &#125; return m+sum; &#125;&#125; 知识点思路：分情况讨论。 所求的是最多有多少客户能够感到满意，包括：1.本来就满意的顾客数量（即，老板不生气时间内的顾客总数）+2.使用密码技巧minutes分钟内，使得本来因老板生气而被赶走的顾客数量。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1652.拆炸弹","path":"/2024/09/11/1652-拆炸弹/","content":"题目你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例 1： 123输入：code = [5,7,1,4], k = 3输出：[12,10,16,13]解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 示例 2： 123输入：code = [1,2,3,4], k = 0输出：[0,0,0,0]解释：当 k 为 0 时，所有数字都被 0 替换。 示例 3： 123输入：code = [2,4,9,3], k = -2输出：[12,5,6,13]解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。 提示： n == code.length 1 &lt;= n &lt;= 100 1 &lt;= code[i] &lt;= 100 -(n - 1) &lt;= k &lt;= n - 1 题解1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int[] decrypt(int[] code, int k) &#123; int n=code.length; int[] m = new int[n]; Arrays.fill(m,0); if(k==0)&#123; return m; &#125; int j=0; int sum=0; int count=0;// 记录窗口的数量 if(k&gt;0)&#123; // 窗口位置[1，k]; for(int i=1;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125;else&#123; // 窗口位置[n-k, n-k+k) k=-k; for(int i=n-k;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125; &#125;&#125; 优化：寻找规律，可以发现当k大于0和k小于0时，只有窗口的起始位置不一样。因此，两类可以合并 1234567891011121314151617181920212223242526class Solution &#123; public int[] decrypt(int[] code, int k) &#123; int n=code.length; int[] m = new int[n]; Arrays.fill(m,0); if(k==0)&#123; return m; &#125; int j=0; int sum=0; int count=0; int r = k&gt;0 ? 1 : n+k; k = Math.abs(k); for(int i=r;j&lt;n;i++)&#123; sum+=code[(i+n)%n]; if(count&lt;k-1)&#123; count++; continue; &#125; m[j]=sum; j++; sum-=code[(i+n-(k-1))%n]; &#125; return m; &#125;&#125; 知识点滑动窗口问题，主要考虑窗口大小以及窗口的起始位置。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2379.得到 K 个黑块的最少涂色次数","path":"/2024/09/11/2379-得到-K-个黑块的最少涂色次数/","content":"题目给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 &#39;W&#39; 要么是 &#39;B&#39; ，表示第 i 块的颜色。字符 &#39;W&#39; 和 &#39;B&#39; 分别表示白色和黑色。 给你一个整数 k ，表示想要 连续 黑色块的数目。 每一次操作中，你可以选择一个白色块将它 涂成 黑色块。 请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。 示例 1： 1234567输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7输出：3解释：一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。得到 blocks = &quot;BBBBBBBWBW&quot; 。可以证明无法用少于 3 次操作得到 7 个连续的黑块。所以我们返回 3 。 示例 2： 12345输入：blocks = &quot;WBWBBBW&quot;, k = 2输出：0解释：不需要任何操作，因为已经有 2 个连续的黑块。所以我们返回 0 。 提示： n == blocks.length 1 &lt;= n &lt;= 100 blocks[i] 要么是 &#39;W&#39; ，要么是 &#39;B&#39; 。 1 &lt;= k &lt;= n 题解12345678910111213141516171819202122class Solution &#123; public int minimumRecolors(String blocks, int k) &#123; int n=0; int min= Integer.MAX_VALUE; char[] block = blocks.toCharArray();; for(int i=0;i&lt;block.length;i++)&#123; if(block[i]==&#x27;W&#x27;)&#123; n++; &#125; if(i&lt;k-1)&#123; continue; &#125; if(n&lt;min)&#123; min=n; &#125; if(block[i-(k-1)]==&#x27;W&#x27;)&#123; n--; &#125; &#125; return min; &#125;&#125; 知识点常规滑动窗口","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2090.半径为 k 的子数组平均值","path":"/2024/09/11/2090-半径为-k-的子数组平均值/","content":"题目给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。 半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。 构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。 x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。 例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。 示例 1： 123456789输入：nums = [7,4,3,9,1,8,5,2,6], k = 3输出：[-1,-1,-1,5,4,4,-1,-1,-1]解释：- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。 示例 2： 12345输入：nums = [100000], k = 0输出：[100000]解释：- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。 示例 3： 1234输入：nums = [8], k = 100000输出：[-1]解释：- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。 提示： n == nums.length 1 &lt;= n &lt;= 105 0 &lt;= nums[i], k &lt;= 105 题解12345678910111213141516171819202122232425class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; int n = nums.length; int[] avgs = new int[n]; Arrays.fill(avgs,-1); if(n==1&amp;&amp;k==0)&#123; return nums; &#125; if(2*k&gt;=n)&#123; return avgs; &#125; long sum=0;// 防止超限 int j=k; for(int i=0;i&lt;n;i++)&#123; sum+=nums[i]; if(i&lt;2*k)&#123; continue; &#125; avgs[j]=(int)(sum/(2*k+1)); j++; sum-=nums[i-(2*k)]; &#125; return avgs; &#125;&#125; 知识点常规定长滑动窗口问题，注意加上坐标中心，同时注意使用long型，否则会超限。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1343.大小为 K 且平均值大于等于阈值的子数组数目","path":"/2024/09/11/1343-大小为-K-且平均值大于等于阈值的子数组数目/","content":"题目给你一个整数数组 arr 和两个整数 k 和 threshold 。 请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。 示例 1： 123输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4输出：3解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。 示例 2： 123输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5输出：6解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。 提示： 1 &lt;= arr.length &lt;= 105 1 &lt;= arr[i] &lt;= 104 1 &lt;= k &lt;= arr.length 0 &lt;= threshold &lt;= 104 题解123456789101112131415161718class Solution &#123; public int numOfSubarrays(int[] arr, int k, int threshold) &#123; int num=0; double sum=0.0; for(int i=0;i&lt;arr.length;i++)&#123; sum+=arr[i]; if(i&lt;k-1)&#123; continue; &#125; if(sum/k&gt;=threshold)&#123; num++; &#125; sum-=arr[i-(k-1)]; &#125; return num; &#125;&#125; 知识点常规滑动窗口问题，无难点。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"643.子数组最大平均数 I","path":"/2024/09/11/643-子数组最大平均数-I/","content":"题目给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。 示例 1： 123输入：nums = [1,12,-5,-6,50,3], k = 4输出：12.75解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 示例 2： 12输入：nums = [5], k = 1输出：5.00000 提示： n == nums.length 1 &lt;= k &lt;= n &lt;= 105 -104 &lt;= nums[i] &lt;= 104 题解1234567891011121314151617181920212223class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; // if(nums.length==1)&#123; // return nums[0]; // &#125; double avg = 0.0; double max=Integer.MIN_VALUE; int sum=0; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; if(i&lt;k-1)&#123; continue; &#125; avg = 1.0*sum/k; if(avg&gt;max)&#123; max = avg; &#125; sum-=nums[i-(k-1)]; &#125; return max; &#125;&#125; 知识点常规的滑动窗口问题，注意考虑特殊情况：最大值的初始化设置 整型最大值：Integer.MAX_VALUE 整型最小值：Integer.MIN_VALUE","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"1456.定长子串中元音的最大数目","path":"/2024/09/10/1456-定长子串中元音的最大数目/","content":"题目给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例 1： 123输入：s = &quot;abciiidef&quot;, k = 3输出：3解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。 示例 2： 123输入：s = &quot;aeiou&quot;, k = 2输出：2解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 123输入：s = &quot;leetcode&quot;, k = 3输出：2解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。 示例 4： 123输入：s = &quot;rhythms&quot;, k = 4输出：0解释：字符串 s 中不含任何元音字母。 示例 5： 12输入：s = &quot;tryhard&quot;, k = 4输出：1 提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length 题解123456789101112131415161718192021222324252627class Solution &#123; public int maxVowels(String S, int k) &#123; char[] s = S.toCharArray(); int max=0; int v=0; for(int i=0;i&lt;s.length;i++)&#123; // 进入窗口 if(s[i]==&#x27;a&#x27;||s[i] == &#x27;e&#x27; || s[i] == &#x27;i&#x27; || s[i] == &#x27;o&#x27; || s[i] == &#x27;u&#x27;)&#123; v++; &#125; // 未到窗口大小 if(i&lt;k-1)&#123; continue; &#125; // 更新 if(v&gt;max)&#123; max=v; &#125; // 出 char out = s[i-(k-1)]; if (out == &#x27;a&#x27; || out == &#x27;e&#x27; || out == &#x27;i&#x27; || out == &#x27;o&#x27; || out == &#x27;u&#x27;) &#123; v--; &#125; &#125; return max; &#125;&#125; 知识点三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果 i &lt; k−1 则重复第一步。更新：更新答案。一般是更新最大值&#x2F;最小值。出：下标为 i − (k-1) 的元素离开窗口，更新相关统计量。","tags":["算法"],"categories":["LeetCode","定长滑动窗口_基础"]},{"title":"2552.统计上升四元组（题解都看不懂，害）","path":"/2024/09/10/2552-统计上升四元组/","content":"题目给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。 如果一个四元组 (i, j, k, l) 满足以下条件，我们称它是上升的： 0 &lt;= i &lt; j &lt; k &lt; l &lt; n 且 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。 示例 1： 123456输入：nums = [1,3,2,4,5]输出：2解释：- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。没有其他的四元组，所以我们返回 2 。 示例 2： 123输入：nums = [1,2,3,4]输出：0解释：只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。 提示： 4 &lt;= nums.length &lt;= 4000 1 &lt;= nums[i] &lt;= nums.length nums 中所有数字 互不相同 ，nums 是一个排列。 代码知识点"},{"title":"bat批处理脚本自动部署Hexo博客","path":"/2024/09/10/bat批处理脚本自动部署Hexo博客/","content":"原因每次提交博客，都需要进行hexo clean hexo g hexo d指令，十分繁琐 优点Windows中的.bat文件可以直接点击运行，同时还能把多条指令写进一个.bat文件。 代码1234@echo offD:cd D:\\bloghexo clean &amp;&amp; hexo g &amp;&amp; hexo d 指令说明@echo off，关闭回显。D:，切换到博客站点目录所在的盘符cd D:\\blog，进入站点目录hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，清理缓存和部署目录，生成最新的静态文件，部署新生成的静态文件。","tags":["Hexo","自动部署"],"categories":["脚本"]},{"title":"49.字母异位词分组","path":"/2024/09/10/49-字母异位词分组/","content":"题目给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 示例 1: 12输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 示例 2: 12输入: strs = [&quot;&quot;]输出: [[&quot;&quot;]] 示例 3: 12输入: strs = [&quot;a&quot;]输出: [[&quot;a&quot;]] 提示： 1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i] 仅包含小写字母 题解思路：字母异位词的两个字符串的字母相同，仅是顺序不一样。因此，通过排序得到的字符串肯定一样。可以通过哈希表来存储，其中键为排序后的字符串，值为该组异位字符词。 1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); List&lt;String&gt; list; for (String str : strs) &#123;// 遍历 char[] array = str.toCharArray();// 字符串转字符数组 Arrays.sort(array);// 对字符数组排序 String key = new String(array); if(map.containsKey(key)==true)&#123; list = map.get(key); &#125;else&#123; list = new ArrayList&lt;String&gt;(); &#125; //List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;String&gt;());// map中存在该key，则使用该key对应的value，否则为空List list.add(str); map.put(key, list); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; 知识点HashMap方法 定义：Map&lt;String ,String&gt; map = new HashMap&lt;String ,String&gt;(); 添加键值对：put(Object key, Object value); 获取映射值：getOrDefault(Object key, V defaultValue); 是否有指定key的映射：boolean containsKey(Object key); String 类方法 字符串转换成字符数组：str.toCharArray(); Arrays类方法 对数组进行排序：Arrays.sort();","tags":["HashMap"],"categories":["LeetCode"]},{"title":"这是文章标题","path":"/2024/08/16/20240114/","content":"文章正文"},{"title":"Hello World","path":"/2024/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418:root&#123; --code-autor: &#x27;© 钟意博客🌙&#x27;; --code-tip: &quot;优雅借鉴&quot;;&#125; /*语法高亮*/ .hljs &#123; position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) &#125; .hljs::before &#123; content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 &#125; .highlight:hover .hljs::before &#123; color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; &#125; .hljs-ln &#123; display: inline-block; overflow-x: auto; padding-bottom: 5px &#125; .hljs-ln td &#123; padding: 0; background-color: var(--block) &#125; .hljs-ln::-webkit-scrollbar &#123; height: 10px; border-radius: 5px; background: #333; &#125; .hljs-ln::-webkit-scrollbar-thumb &#123; background-color: #bbb; border-radius: 5px; &#125; .hljs-ln::-webkit-scrollbar-thumb:hover &#123; background: #ddd; &#125; .hljs table tbody tr &#123; border: none &#125; .hljs .hljs-ln-line &#123; padding: 1px 10px; border: none &#125; td.hljs-ln-line.hljs-ln-numbers &#123; border-right: 1px solid #666; &#125; .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name &#123; color: #c78300 &#125; .hljs-link &#123; color: #569cd6; text-decoration: underline &#125; .hljs-built_in, .hljs-type &#123; color: #4ec9b0 &#125; .hljs-number, .hljs-class &#123; color: #2094f3 &#125; .hljs-string, .hljs-meta-string &#123; color: #4caf50 &#125; .hljs-regexp, .hljs-template-tag &#123; color: #9a5334 &#125; .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula &#123; color: #c78300 &#125; .hljs-property &#123; color: #9c67a1; &#125; .hljs-comment, .hljs-quote &#123; color: #57a64a; font-style: italic &#125; .hljs-doctag &#123; color: #608b4e &#125; .hljs-meta, .hljs-meta-keyword, .hljs-tag &#123; color: #9b9b9b &#125; .hljs-variable, .hljs-template-variable &#123; color: #bd63c5 &#125; .hljs-attr, .hljs-attribute, .hljs-builtin-name &#123; color: #d34141 &#125; .hljs-section &#123; color: gold &#125; .hljs-emphasis &#123; font-style: italic &#125; .hljs-strong &#123; font-weight: bold &#125; .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo &#123; color: #c78300 &#125; .hljs-addition &#123; background-color: #144212; display: inline-block; width: 100% &#125; .hljs-deletion &#123; background-color: #600; display: inline-block; width: 100% &#125; .hljs.language-html::before, .hljs.language-xml::before &#123; content: &quot;HTML/XML&quot; &#125; .hljs.language-javascript::before &#123; content: &quot;JavaScript&quot; &#125; .hljs.language-c::before &#123; content: &quot;C&quot; &#125; .hljs.language-cpp::before &#123; content: &quot;C++&quot; &#125; .hljs.language-java::before &#123; content: &quot;Java&quot; &#125; .hljs.language-asp::before &#123; content: &quot;ASP&quot; &#125; .hljs.language-actionscript::before &#123; content: &quot;ActionScript/Flash/Flex&quot; &#125; .hljs.language-bash::before &#123; content: &quot;Bash&quot; &#125; .hljs.language-css::before &#123; content: &quot;CSS&quot; &#125; .hljs.language-asp::before &#123; content: &quot;ASP&quot; &#125; .hljs.language-cs::before, .hljs.language-csharp::before &#123; content: &quot;C#&quot; &#125; .hljs.language-d::before &#123; content: &quot;D&quot; &#125; .hljs.language-golang::before, .hljs.language-go::before &#123; content: &quot;Go&quot; &#125; .hljs.language-json::before &#123; content: &quot;JSON&quot; &#125; .hljs.language-lua::before &#123; content: &quot;Lua&quot; &#125; .hljs.language-less::before &#123; content: &quot;LESS&quot; &#125; .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before &#123; content: &quot;Markdown&quot; &#125; .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before &#123; content: &quot;Objective-C&quot; &#125; .hljs.language-php::before &#123; content: &quot;PHP&quot; &#125; .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before &#123; content: &quot;Perl&quot; &#125; .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before &#123; content: &quot;Python&quot; &#125; .hljs.language-r::before &#123; content: &quot;R&quot; &#125; .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before &#123; content: &quot;Ruby&quot; &#125; .hljs.language-sql::before &#123; content: &quot;SQL&quot; &#125; .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before &#123; content: &quot;Shell&quot; &#125; .hljs.language-swift::before &#123; content: &quot;Swift&quot; &#125; .hljs.language-vb::before &#123; content: &quot;VB/VBScript&quot; &#125; .hljs.language-yaml::before &#123; content: &quot;YAML&quot; &#125; /*stellar主题补偿*/ .md-text pre&gt;.hljs &#123; padding-top: 2rem !important; &#125; .md-text pre &#123; padding: 0 !important; &#125; code &#123; background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; background-size: 20px 20px !important; background-position: 50% !important; &#125; figure::after &#123; content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 &#125; figcaption span &#123; border-radius: 0px 0px 12px 12px !important; &#125; /* 复制代码按钮 */ .highlight &#123; position: relative; &#125; .highlight .code .copy-btn &#123; position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; &#125; .highlight .code .copy-btn:hover &#123; color: var(--text-code); opacity: 0.75; &#125; .highlight .code .copy-btn.success &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; /* 描述 */ .md-text .highlight figcaption span &#123; font-size: small; &#125; /* 折叠 */ code.hljs &#123; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; /*-webkit-line-clamp: 6;*/ padding: 1rem 1rem 0 1rem; /* chino建议 */ &#125; .hljsOpen &#123; -webkit-line-clamp: 99999 !important; &#125; .CodeCloseDiv &#123; color: #999; background: var(--block); display: flex; justify-content: center; margin-top: inherit; margin-bottom: -18px; &#125; .CodeClose &#123; color: #999; margin-top: 3px; background: var(--block); &#125; .highlight button:hover, .highlight table:hover+button &#123; color: var(--swiper-theme-color); opacity: 0.75; &#125; More info: Deployment"},{"path":"/notes/index.html","content":"zh吱吱吱吱"},{"path":"/more/index.html","content":"我的订阅我的歌单关于本站关于博主 .md-text .tag-plugin.timeline .timenode>.body, .md-text .tag-plugin.timeline .timenode>.header { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }"},{"title":"测试2","path":"/notes/test2.html","content":"测试2 2222222222"},{"title":"测试","path":"/notes/test.html","content":"测试 11111111111111"},{"path":"/share/index.html","content":"2024 2024-03-09狠人必备：陈桂林同款手表🐷2024-02-18自制多肉拼盘🌱2024-02-13哦🫨，啊😮，哇😍 Your browser does not support the video tag. 2024-02-13彩菊的正确打开方式😎 Your browser does not support the video tag. 2024-02-13落日余晖 &amp; 皓月当空🌆2024-02-13南京青奥中心🏙️2024-02-11草莓园里摘草莓🍓2024-02-07过年就是要放烟花🎇2024-02-07夕阳下雪白的田野⛄"},{"path":"/js/services/txmap.js","content":"//get请求 $.ajax({ type: 'get', url: 'https://apis.map.qq.com/ws/location/v1/ip', data: { key: 'XRWBZ-J436B-NOKU3-JPDTY-AWCIH-SXF7X', output: 'jsonp', }, dataType: 'jsonp', success: function (res) { ipLoacation = res; } }) function getDistance(e1, n1, e2, n2) { const R = 6371 const { sin, cos, asin, PI, hypot } = Math let getPoint = (e, n) => { e *= PI / 180 n *= PI / 180 return { x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) } } let a = getPoint(e1, n1) let b = getPoint(e2, n2) let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z) let r = asin(c / 2) * 2 * R return Math.round(r); } function showWelcome() { console.log(ipLoacation) let dist = getDistance(107.754444, 31.148725, ipLoacation.result.location.lng, ipLoacation.result.location.lat); //这里换成自己的经纬度 let pos = ipLoacation.result.ad_info.nation; let ip; let posdesc; //根据国家、省份、城市信息自定义欢迎语 switch (ipLoacation.result.ad_info.nation) { case \"日本\": posdesc = \"よろしく，一起去看樱花吗\"; break; case \"美国\": posdesc = \"Let us live in peace!\"; break; case \"英国\": posdesc = \"想同你一起夜乘伦敦眼\"; break; case \"俄罗斯\": posdesc = \"干了这瓶伏特加！\"; break; case \"法国\": posdesc = \"C'est La Vie\"; break; case \"德国\": posdesc = \"Die Zeit verging im Fluge.\"; break; case \"澳大利亚\": posdesc = \"一起去大堡礁吧！\"; break; case \"加拿大\": posdesc = \"拾起一片枫叶赠予你\"; break; case \"中国\": pos = ipLoacation.result.ad_info.province + \" \" + ipLoacation.result.ad_info.city + \" \" + ipLoacation.result.ad_info.district; ip = ipLoacation.result.ip; switch (ipLoacation.result.ad_info.province) { case \"北京市\": posdesc = \"北——京——欢迎你~~~\"; break; case \"天津市\": posdesc = \"讲段相声吧。\"; break; case \"河北省\": posdesc = \"山势巍巍成壁垒，天下雄关。铁马金戈由此向，无限江山。\"; break; case \"山西省\": posdesc = \"展开坐具长三尺，已占山河五百余。\"; break; case \"内蒙古自治区\": posdesc = \"天苍苍，野茫茫，风吹草低见牛羊。\"; break; case \"辽宁省\": posdesc = \"我想吃烤鸡架！\"; break; case \"吉林省\": posdesc = \"状元阁就是东北烧烤之王。\"; break; case \"黑龙江省\": posdesc = \"很喜欢哈尔滨大剧院。\"; break; case \"上海市\": posdesc = \"众所周知，中国只有两个城市。\"; break; case \"江苏省\": switch (ipLoacation.result.ad_info.city) { case \"南京市\": posdesc = \"这是我挺想去的城市啦。\"; break; case \"苏州市\": posdesc = \"上有天堂，下有苏杭。\"; break; default: posdesc = \"散装是必须要散装的。\"; break; } break; case \"浙江省\": posdesc = \"东风渐绿西湖柳，雁已还人未南归。\"; break; case \"河南省\": switch (ipLoacation.result.ad_info.city) { case \"郑州市\": posdesc = \"豫州之域，天地之中。\"; break; case \"南阳市\": posdesc = \"臣本布衣，躬耕于南阳。此南阳非彼南阳！\"; break; case \"驻马店市\": posdesc = \"峰峰有奇石，石石挟仙气。嵖岈山的花很美哦！\"; break; case \"开封市\": posdesc = \"刚正不阿包青天。\"; break; case \"洛阳市\": posdesc = \"洛阳牡丹甲天下。\"; break; default: posdesc = \"可否带我品尝河南烩面啦？\"; break; } break; case \"安徽省\": posdesc = \"蚌埠住了，芜湖起飞。\"; break; case \"福建省\": posdesc = \"井邑白云间，岩城远带山。\"; break; case \"江西省\": posdesc = \"落霞与孤鹜齐飞，秋水共长天一色。\"; break; case \"山东省\": posdesc = \"遥望齐州九点烟，一泓海水杯中泻。\"; break; case \"湖北省\": posdesc = \"来碗热干面！\"; break; case \"湖南省\": posdesc = \"74751，长沙斯塔克。\"; break; case \"广东省\": posdesc = \"老板来两斤福建人。\"; break; case \"广西壮族自治区\": posdesc = \"桂林山水甲天下。\"; break; case \"海南省\": posdesc = \"朝观日出逐白浪，夕看云起收霞光。\"; break; case \"四川省\": posdesc = \"康康川妹子。\"; break; case \"贵州省\": posdesc = \"茅台，学生，再塞200。\"; break; case \"云南省\": posdesc = \"玉龙飞舞云缠绕，万仞冰川直耸天。\"; break; case \"西藏自治区\": posdesc = \"躺在茫茫草原上，仰望蓝天。\"; break; case \"陕西省\": posdesc = \"来份臊子面加馍。\"; break; case \"甘肃省\": posdesc = \"羌笛何须怨杨柳，春风不度玉门关。\"; break; case \"青海省\": posdesc = \"牛肉干和老酸奶都好好吃。\"; break; case \"宁夏回族自治区\": posdesc = \"大漠孤烟直，长河落日圆。\"; break; case \"新疆维吾尔自治区\": posdesc = \"驼铃古道丝绸路，胡马犹闻唐汉风。\"; break; case \"台湾省\": posdesc = \"我在这头，大陆在那头。\"; break; case \"香港特别行政区\": posdesc = \"永定贼有残留地鬼嚎，迎击光非岁玉。\"; break; case \"澳门特别行政区\": posdesc = \"性感荷官，在线发牌。\"; break; default: posdesc = \"带我去你的城市逛逛吧！\"; break; } break; default: posdesc = \"带我去你的国家逛逛吧。\"; break; } //根据本地时间切换欢迎语 let timeChange; let date = new Date(); if (date.getHours() >= 5 && date.getHours() < 11) timeChange = \"上午好，一日之计在于晨！\"; else if (date.getHours() >= 11 && date.getHours() < 13) timeChange = \"中午好，该摸鱼吃午饭了。\"; else if (date.getHours() >= 13 && date.getHours() < 15) timeChange = \"下午好，懒懒地睡个午觉吧！\"; else if (date.getHours() >= 15 && date.getHours() < 16) timeChange = \"三点几啦，一起饮茶呀！\"; else if (date.getHours() >= 16 && date.getHours() < 19) timeChange = \"夕阳无限好！\"; else if (date.getHours() >= 19 && date.getHours() < 24) timeChange = \"晚上好，夜生活嗨起来！\"; else timeChange = \"夜深了，早点休息，少熬夜。\"; try { //自定义文本和需要放的位置 document.getElementById(\"welcome-info\").innerHTML = `欢迎来自 ${pos} 的小伙伴，${timeChange}您现在距离站长约 ${dist} 公里， ${posdesc} `; } catch (err) { // console.log(\"Pjax无法获取#welcome-info元素🙄🙄🙄\") } } window.onload = showWelcome; // 如果使用了pjax在加上下面这行代码 document.addEventListener('pjax:complete', showWelcome);"},{"path":"/more/about/index.html","content":"我的订阅我的歌单关于本站关于博主 这里是瓦豆鲁迪的个人站点。我在这里记录生活的点滴与感悟，也在这里分享和技术相关的内容。希望我的内容对您有所帮助，如果您有任何想法或问题，欢迎在评论区留言。 站点信息 本站使用 Hexo 框架和 Stellar 主题创建，代码托管于 GitHub，站点部署于 Vercel。 评论系统使用 Waline 创建，系统部署于 Vercel，数据存储于 LeanCloud。 订阅系统使用 友链朋友圈 创建，系统部署于 Vercel，数据存储于 GitHub。 隐私声明 本站非常重视您的隐私及数据安全，在访问本站时，不会收集和存储您的任何数据。 在使用本站评论系统时，会收集和存储您的相关信息，详见 Waline 隐私声明。 本站仅会使用您的信息来提供评论服务，并且尽最大努力保护您的隐私及数据安全。 版权声明 本站所有内容均采用 署名-非商业性使用-禁止演绎 4.0 国际 许可协议，未经授权请勿转载。 本站所有内容均由本人亲自撰写，没有使用任何人工智能生成技术。 免责声明 本站所有内容不代表任何组织的立场和意见，也不构成任何形式的建议或指导。 本站对内容的真实性、完整性、准确性和及时性不作任何保证，也不承担任何法律责任。"},{"path":"/more/music/index.html","content":"我的订阅我的歌单关于本站关于博主"},{"path":"/more/me/index.html","content":"我的订阅我的歌单关于本站关于博主 我的职业目前是一名 IT 系统工程师，毕业之后开始专注微软技术。从操作系统 Windows Server 和虚拟化技术 Hyper-V，到统一通信平台 Exchange、Lync、SharePoint Server，再到 System Center、Dynamics Server 系列产品，一路追随微软的脚步成长。最近几年，随着云计算与低代码的日益发展，也先后熟悉了 Azure、Power Platform 等平台。我当下的目标是成为一名微软技术顾问。 人格类型 测试结果来自 16Personalities。 我的游戏 联系方式 Emailmailto:parasol@waddledee.com Telegramhttps://t.me/parasolwaddledee"},{"title":"这是分页标题","path":"/wiki/hexo-stellar/index.html","content":"z是stellar"},{"title":"测试","path":"/wiki/hexo-stellar/test.html","content":"帆帆帆帆帆帆帆帆。为什么没有啊"}]